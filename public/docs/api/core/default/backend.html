<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>core.default.backend API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em;background:#EEE}#content{padding:20px}#sidebar{padding:30px;overflow:hidden;background:#07085d}#sidebar > *:last-child{margin-bottom:2cm}#sidebar::-webkit-scrollbar{width:8px}#sidebar::-webkit-scrollbar-track{border-radius:10px;background:#f1f1f100}#sidebar::-webkit-scrollbar-thumb{border-radius:10px;background:linear-gradient( 37deg,rgb(247,70,58) 1%,rgb(180,62,121) 80% )}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}a.sidebar{color:white;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#f7463a}a.nav-header{color:white}img.logo-img{display:block;margin-left:auto;margin-right:auto;width:25%}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#e0e0e0;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{height:100vh;overflow:auto;position:sticky;top:0;background:#07085d}#content{width:70%;max-width:200ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<!--<link rel="stylesheet"
href='https://cdevwebsitestaging.s3.amazonaws.com/bootstrap/css/bootstrap.min.css'>-->
<script href='/bootstrap/css/bootstrap.js'></script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>core.default.backend</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import json
import os

from pathlib import PosixPath, WindowsPath
from pydantic.main import BaseModel
from pydantic.types import DirectoryPath, FilePath

from typing import Dict, List, Any, Tuple
import uuid

from core.constructs.workspace import Workspace


from ..constructs.backend import Backend_Configuration, Backend
from ..constructs.backend_exceptions import *

from ..constructs.components import (
    Component_Change_Type,
    ComponentModel,
    Component_Difference,
)
from ..constructs.resource import (
    Resource_Change_Type,
    Resource_Difference,
    Resource_Reference_Change_Type,
    ResourceModel,
    Resource_Reference_Difference,
    ResourceReferenceModel,
)
from ..constructs.resource_state import Resource_State
from ..utils import file_manager, hasher as cdev_hasher


class LocalBackendError(BackendError):
    pass


class CanNotFindResourceStateFile(LocalBackendError):
    pass


class InvalidResourceStateData(LocalBackendError):
    pass



class SetEncoder(json.JSONEncoder):
    def default(self, obj):
       if isinstance(obj, set):
          return list(obj)
       return json.JSONEncoder.default(self, obj)


class Local_Backend_Configuration(Backend_Configuration):
    def __init__(self, config: Dict) -&gt; None:
        &#34;&#34;&#34;
        Represents the data needed to create a new cdev workspace:

        Parameters:
            python_module: The name of the python module to load as the backend
            config: configuration option for the backend

        &#34;&#34;&#34;

        super().__init__(
            **{
                &#34;python_module&#34;: &#34;core.default.backend&#34;,
                &#34;python_class&#34;: &#34;LocalBackend&#34;,
                &#34;config&#34;: config,
            }
        )


class LocalCentralFile(BaseModel):
    resource_state_locations: Dict[str, str]  # uuid -&gt; file location
    top_level_states: List[str]  # uuid
    resource_state_names: List[str]

    def __init__(
        __pydantic_self__,
        resource_state_locations: Dict[str, str],
        top_level_states: List[str],
        resource_state_names: List[str],
    ) -&gt; None:
        super().__init__(
            **{
                &#34;resource_state_locations&#34;: resource_state_locations,
                &#34;top_level_states&#34;: top_level_states,
                &#34;resource_state_names&#34;: resource_state_names,
            }
        )


class LocalBackend(Backend):
    # Structurally, this implementation will have a central json that can be used as an index into more precise json files. For example, each resource state will be its own json file, but
    # the central file will keep track of each one.
    def __init__(
        self, base_folder: DirectoryPath, central_state_file: FilePath = None
    ) -&gt; None:
        &#34;&#34;&#34;
        Implementation of a Backend using locally stored json files as the peristent storage medium. This backend should only be used for small project as it does not provide any mechanisms
        to work well when multiple people edit the state. Also this is a single threaded implementation.

        *** For now, we will not use any kind of WAL for make changes to underlying state files, so it can be bad if you kill the process unexpectedly. In the future, it will use some mechanism
        to prevent this. ***

        Arguments:
            base_folder (DirectoryPath): Path to a folder to use for storing local json files. Defaults to cdev setting if not provided.
            central_state_file (FilePath): Path to the central state file. Defaults to cdev setting if not provided.
        &#34;&#34;&#34;

        
        DEFAULT_CENTRAL_STATE_FILE = os.path.join(base_folder, &#34;local_state.json&#34;)


        self.base_folder = base_folder
        self.central_state_file = (
            central_state_file if central_state_file else DEFAULT_CENTRAL_STATE_FILE
        )

        if not os.path.isdir(self.base_folder):
            print(f&#34;ERROR HERE&#34;)
            raise Exception

        if not os.path.isfile(self.central_state_file):
            self._central_state = LocalCentralFile({}, [], [])

        else:
            with open(self.central_state_file, &#34;r&#34;) as fh:
                self._central_state = LocalCentralFile(**json.load(fh))

    def _write_central_file(self):
        file_manager.safe_json_write(self._central_state.dict(), self.central_state_file)

    def _write_resource_state_file(self, resource_state: Resource_State, fp: FilePath):
        file_manager.safe_json_write(resource_state.dict(), fp)
    

    # Api for working with Resource States
    def create_resource_state(
        self, name: str, parent_resource_state_uuid: str = None
    ) -&gt; str:
        # Create the new resource state
        if name in set(self._central_state.resource_state_names):
            raise ResourceStateAlreadyExists(&#34;Creating resource state with taken name&#34;)

        resource_state_uuid = str(uuid.uuid4())
        if not parent_resource_state_uuid:
            # Create this as a top level resource state
            new_resource_state = Resource_State(name, resource_state_uuid)
            self._central_state.top_level_states.append(new_resource_state.uuid)

        else:
            new_resource_state = Resource_State(
                name=name,
                uuid=resource_state_uuid,
                components=[],
                parent_uuid=parent_resource_state_uuid,
            )

        filename = os.path.join(
            self.base_folder, f&#34;resource_state_{new_resource_state.uuid}.json&#34;
        )

        self._central_state.resource_state_locations[new_resource_state.uuid] = filename
        self._central_state.resource_state_names.append(new_resource_state.name)

        self._write_central_file()
        self._write_resource_state_file(new_resource_state, filename)

        return new_resource_state.uuid

    def delete_resource_state(self, resource_state_uuid: str):
        if not resource_state_uuid in self._central_state.resource_state_locations:
            raise ResourceStateDoesNotExist(
                f&#34;Resource state: {resource_state_uuid} does not exist&#34;
            )

        resource_state_to_delete = self.get_resource_state(resource_state_uuid)

        if resource_state_to_delete.children:
            # Can not delete resource state with children
            raise ResourceStateNotEmpty(&#34;Resource state has child resource states&#34;)

        if not len(resource_state_to_delete.components) == 0:
            # Can not delete a non empty resource state
            raise ResourceStateNotEmpty(&#34;Resource state has components&#34;)

        if resource_state_to_delete.parent_uuid:
            # Need to remove this as child of parent
            pass

        else:
            # if the resource state had no parent, then it was a top level resource state
            self._central_state.top_level_states.remove(resource_state_to_delete.uuid)

        self._central_state.resource_state_names.remove(resource_state_to_delete.name)
        file_location = self._central_state.resource_state_locations.pop(
            resource_state_to_delete.uuid
        )

        self._write_central_file()
        os.remove(file_location)

    def get_resource_state(self, resource_state_uuid: str) -&gt; Resource_State:
        if not resource_state_uuid in self._central_state.resource_state_locations:
            raise ResourceStateDoesNotExist(
                f&#34;Resource State: {resource_state_uuid} does not exists&#34;
            )

        file_location = self._central_state.resource_state_locations.get(
            resource_state_uuid
        )

        if not os.path.isfile(file_location):
            raise CanNotFindResourceStateFile(
                f&#34;Can not find resource state file for {resource_state_uuid}&#34;
            )

        try:
            return file_manager.load_resource_state(file_location)


        except Exception as e:
            raise InvalidResourceStateData(
                f&#34;Ivalid data for Resource State from file {file_location} for resource state {resource_state_uuid}; {e}&#34;
            )

    def get_top_level_resource_states(self) -&gt; List[Resource_State]:
        rv = []
        
        for resource_id in self._central_state.top_level_states:
            # Let any exception from loading a state pass up to caller
            rv.append(self.get_resource_state(resource_id))

        
        return rv

    # Components
    def _create_component(self, resource_state_uuid: str, component_name: str):

        resource_state = self.get_resource_state(resource_state_uuid)
        resource_state_file_location = self._get_resource_state_file_location(
            resource_state_uuid
        )

        if component_name in set(x.name for x in resource_state.components):
            # Cant not have two components of the same name in the same resource state
            raise ComponentAlreadyExists(
                f&#34;Component already exists with name {component_name} in Resource State {resource_state_uuid}&#34;
            )

        # Create the new component
        new_component = ComponentModel(component_name)
        resource_state.components.append(new_component)

        # Create a uuid for the component
        component_uuid = str(uuid.uuid4())
        resource_state.component_name_to_uuid[component_name] = component_uuid

        self._write_resource_state_file(resource_state, resource_state_file_location)

    def _delete_component(self, resource_state_uuid: str, component_name: str):

        resource_state = self.get_resource_state(resource_state_uuid)
        resource_state_file_location = self._get_resource_state_file_location(
            resource_state_uuid
        )

        if not component_name in set(x.name for x in resource_state.components):
            # Component of that name does not exists
            raise ComponentDoesNotExist(
                f&#34;Could not find component {component_name} in Resource State {resource_state_uuid}&#34;
            )

        deleteing_component = next(
            x for x in resource_state.components if x.name == component_name
        )

        if not len(deleteing_component.resources) == 0:
            raise ComponentNotEmpty(
                f&#34;Can not delete Component {component_name} in Resource State {resource_state_uuid} because the component is not empty&#34;
            )

        resource_state.components = [
            x for x in resource_state.components if not x.name == component_name
        ]

        
        resource_state.component_name_to_uuid.pop(component_name)

        self._write_resource_state_file(resource_state, resource_state_file_location)


    def _update_component_name(self, resource_state_uuid: str, previous_component_name: str, new_component_name: str):
        resource_state = self.get_resource_state(resource_state_uuid)
        resource_state_file_location = self._get_resource_state_file_location(
            resource_state_uuid
        )

        if not previous_component_name in set(x.name for x in resource_state.components) or not previous_component_name in resource_state.component_name_to_uuid:
            # Component of that name does not exists
            raise ComponentDoesNotExist(
                f&#34;Could not find component {previous_component_name} in Resource State {resource_state_uuid}&#34;
            )


        if new_component_name in set(x.name for x in resource_state.components) or new_component_name in resource_state.component_name_to_uuid:
            # Cant not have two components of the same name in the same resource state
            raise ComponentAlreadyExists(
                f&#34;Component already exists with name {new_component_name} in Resource State {resource_state_uuid}&#34;
            )

        # get the component to rename
        rename_component = next(
            x for x in resource_state.components if x.name == previous_component_name
        )

        # remove the component from the list of components
        resource_state.components = [
            x for x in resource_state.components if not x.name == previous_component_name
        ]

        # Since ComponentModels are frozen, we can just change the name
        # So we make a dict of the current ComponentModel then change the name and use the dict as input
        # for a new ComponentModel Obj. Then add the new Obj to the resource state
        component_as_dict = rename_component.dict()
        component_as_dict[&#39;name&#39;] = new_component_name
        new_component = ComponentModel(**component_as_dict)

        resource_state.components.append(new_component)

        # Update the name to uuid dict
        resource_state.component_name_to_uuid.pop(previous_component_name)
        resource_state.component_name_to_uuid[new_component_name] = new_component


        self._write_resource_state_file(resource_state, resource_state_file_location)

        

    def get_component(
        self, resource_state_uuid: str, component_name: str
    ) -&gt; ComponentModel:

        resource_state = self.get_resource_state(resource_state_uuid)

        if not component_name in set(x.name for x in resource_state.components):
            # Component of that name does not exists
            raise ComponentDoesNotExist(
                f&#34;Can not find Component {component_name} in Resource State {resource_state_uuid}&#34;
            )

        return next(x for x in resource_state.components if x.name == component_name)


    def get_component_uuid(self, resource_state_uuid: str, component_name: str) -&gt; str:
        resource_state = self.get_resource_state(resource_state_uuid)

        if not component_name in resource_state.component_name_to_uuid:
            raise ComponentDoesNotExist(
                f&#34;Can not find Component {component_name} in Resource State {resource_state_uuid}&#34;
            )

        component_uuid = resource_state.component_name_to_uuid.get(component_name)

        return cdev_hasher.hash_list([resource_state_uuid, component_uuid])


    def update_component(
        self, resource_state_uuid: str, component_difference: Component_Difference
    ):
        if component_difference.action_type == Component_Change_Type.CREATE:
            self._create_component(resource_state_uuid , component_difference.new_name)
            return

        elif component_difference.action_type == Component_Change_Type.DELETE:
            self._delete_component(resource_state_uuid, component_difference.previous_name)
            return

        elif component_difference.action_type == Component_Change_Type.UPDATE_IDENTITY:
            return

        elif  component_difference.action_type == Component_Change_Type.UPDATE_NAME:
            self._update_component_name(resource_state_uuid, component_difference.previous_name, component_difference.new_name)

        else:
            raise Exception(f&#34;Component Action type not supported {component_difference.action_type}&#34;)


    def create_resource_change_transaction(
        self, resource_state_uuid: str, component_name: str, diff: Resource_Difference
    ) -&gt; Tuple[str, str]:
        resource_state = self.get_resource_state(resource_state_uuid)
        resource_state_file_location = self._get_resource_state_file_location(
            resource_state_uuid
        )

        transaction_token = str(uuid.uuid4())

        ruuid = diff.new_resource.ruuid if diff.new_resource else diff.previous_resource.ruuid

        namespace_token = cdev_hasher.hash_list([resource_state_uuid, self.get_component_uuid(resource_state_uuid, component_name), ruuid])

        resource_state.resource_changes[transaction_token] = (component_name, diff)

        self._write_resource_state_file(resource_state, resource_state_file_location)

        return transaction_token, namespace_token


    def complete_resource_change(
        self,
        resource_state_uuid: str,
        component_name: str,
        diff: Resource_Difference,
        transaction_token: str,
        cloud_output: Dict = None,
        resolved_cloud_information: Dict={}
    ):

        resource_state = self.get_resource_state(resource_state_uuid)
        resource_state_file_location = self._get_resource_state_file_location(
            resource_state_uuid
        )

        
        if not transaction_token in resource_state.resource_changes:
            
            raise ResourceChangeTransactionDoesNotExist(
                f&#34;Transaction {transaction_token} does not exist in Resource State {resource_state_uuid}&#34;
            )

        component = self.get_component(resource_state_uuid, component_name)
        
        new_component = self._update_component(component, diff, cloud_output, resolved_cloud_information)
        
        
        resource_state.components = [
            x for x in resource_state.components if not x.name == component.name
        ] + [new_component]

        resource_state.resource_changes.pop(transaction_token)

        self._write_resource_state_file(resource_state, resource_state_file_location)
        

    def fail_resource_change(
        self,
        resource_state_uuid: str,
        component_name: str,
        diff: Resource_Difference,
        transaction_token: str,
        failed_state: Dict,
    ):

        resource_state = self.get_resource_state(resource_state_uuid)
        resource_state_file_location = self._get_resource_state_file_location(
            resource_state_uuid
        )

        if not transaction_token in resource_state.resource_changes:
            raise ResourceChangeTransactionDoesNotExist(
                f&#34;Transaction {transaction_token} does not exist in Resource State {resource_state_uuid}&#34;
            )

        resource_state.resource_changes.pop(transaction_token)
        resource_state.failed_changes[transaction_token] = (
            component_name,
            diff,
            failed_state,
        )

        self._write_resource_state_file(resource_state, resource_state_file_location)

    def change_failed_state_of_resource_change(
        self, resource_state_uuid: str, transaction_token: str, new_failed_state: Dict
    ):

        resource_state = self.get_resource_state(resource_state_uuid)
        resource_state_file_location = self._get_resource_state_file_location(
            resource_state_uuid
        )

        if not transaction_token in resource_state.failed_changes:
            raise ResourceChangeTransactionDoesNotExist(
                f&#34;Transaction {transaction_token} does not exist in Resource State {resource_state_uuid}&#34;
            )

        previous_component_name, previous_diff, _ = resource_state.failed_changes.get(
            transaction_token
        )

        resource_state.failed_changes[transaction_token] = (
            previous_component_name,
            previous_diff,
            new_failed_state,
        )

        self._write_resource_state_file(resource_state, resource_state_file_location)

    def recover_failed_resource_change(
        self,
        resource_state_uuid: str,
        transaction_token: str,
        to_previous_state: bool = True,
        cloud_output: Dict = None,
    ):

        resource_state = self.get_resource_state(resource_state_uuid)
        resource_state_file_location = self._get_resource_state_file_location(
            resource_state_uuid
        )

        if not transaction_token in resource_state.failed_changes:
            raise ResourceChangeTransactionDoesNotExist(
                f&#34;Transaction {transaction_token} does not exist in Resource State {resource_state_uuid}&#34;
            )

        component_name, diff, _ = resource_state.failed_changes.pop(transaction_token)

        if not to_previous_state:
            component = self.get_component(component_name)

            new_component = self._update_component(component, diff, cloud_output)

            resource_state.components = [
                x for x in resource_state.components if not x.name == component_name
            ] + [new_component]

        self._write_resource_state_file(resource_state, resource_state_file_location)

    def remove_failed_resource_change(
        self, resource_state_uuid: str, transaction_token: str
    ):

        resource_state = self.get_resource_state(resource_state_uuid)
        resource_state_file_location = self._get_resource_state_file_location(
            resource_state_uuid
        )

        if not transaction_token in resource_state.failed_changes:
            raise ResourceChangeTransactionDoesNotExist(
                f&#34;Transaction {transaction_token} does not exist in Resource State {resource_state_uuid}&#34;
            )

        resource_state.failed_changes.pop(transaction_token)

        self._write_resource_state_file(resource_state, resource_state_file_location)

    def resolve_reference_change(
        self,
        resource_state_uuid: str,
        diff: Resource_Reference_Difference,
    ):
        resource_state = self.get_resource_state(resource_state_uuid)
        resource_state_file_location = self._get_resource_state_file_location(
            resource_state_uuid
        )

        component = self.get_component(resource_state_uuid, diff.originating_component_name)

        _reference_resource_state = resource_state
        if diff.resource_reference.is_in_parent_resource_state:
            if not resource_state.parent_uuid:
                raise ResourceReferenceError(
                    f&#34;Current Resource State {resource_state_uuid} does not have a Parent Resource State to resolve {diff} to&#34;
                )

            _reference_resource_state = self.get_resource_state(
                resource_state.parent_uuid
            )

        try:
            _referenced_component = self.get_component(
                _reference_resource_state.uuid, diff.resource_reference.component_name
            )
        except ComponentDoesNotExist:
            raise ResourceReferenceError(
                f&#34;Resource State {_reference_resource_state.uuid} does not contain component {diff.resource_reference.component_name} for {diff}&#34;
            )

        all_parent_resources = set(
            [f&#34;{x.ruuid}{x.name}&#34; for x in _referenced_component.resources]
        )

        if (
            not f&#34;{diff.resource_reference.ruuid}{diff.resource_reference.name}&#34;
            in all_parent_resources
        ):
            raise ResourceReferenceError(
                f&#34;Could not find resource {diff.resource_reference.ruuid};{diff.resource_reference.name} in parent component&#34;
            )

        if diff.action_type == Resource_Reference_Change_Type.CREATE:
            
            reference_id = (
                f&#34;{diff.resource_reference.ruuid}{diff.resource_reference.name}&#34;
            )

            # resolve the reference by adding a count to the reference counter in the referenced component
            if not reference_id in _referenced_component.external_references:
                _referenced_component.external_references[reference_id] = {&#34;cnt&#34;: 1}

            else:
                previous_cnt = _referenced_component.external_references[
                    reference_id
                ].get(&#34;cnt&#34;)
                _referenced_component.external_references[reference_id] = {
                    &#34;cnt&#34;: previous_cnt + 1
                }

            # Add this to the references for this component
            component.references.append(diff.resource_reference)

        elif diff.action_type == Resource_Reference_Change_Type.DELETE:
            
            reference_id = (
                f&#34;{diff.resource_reference.ruuid}{diff.resource_reference.name}&#34;
            )

            # resolve the dereference by subtracting a count to the reference counter in the referenced component
            if not reference_id in _referenced_component.external_references:
                raise ResourceReferenceError(
                    f&#34;Trying to deference resource that does not have reference info&#34;
                )

            else:
                previous_cnt = _referenced_component.external_references[
                    reference_id
                ].get(&#34;cnt&#34;)
                _referenced_component.external_references[reference_id] = {
                    &#34;cnt&#34;: previous_cnt - 1
                }

            if _referenced_component.external_references[reference_id] == 0:
                _referenced_component.external_references.pop(reference_id)

            # Pop this references for this component
            component.references.remove(diff.resource_reference)

        _reference_resource_state.components = [
            x
            for x in resource_state.components
            if not x.name == _referenced_component.name
        ] + [_referenced_component]
        resource_state.components = [
            x for x in resource_state.components if not x.name == component.name
        ] + [component]

        if diff.resource_reference.is_in_parent_resource_state:
            # if the reference is from the parent resource state then we need to update it so that it knows that the reference was resolved
            _reference_resource_state_fp = self._get_resource_state_file_location(
                _reference_resource_state.uuid
            )

            self._write_resource_state_file(
                _reference_resource_state, _reference_resource_state_fp
            )

        self._write_resource_state_file(resource_state, resource_state_file_location)

    # Get resources and cloud output
    def get_resource_by_name(
        self,
        resource_state_uuid: str,
        component_name: str,
        resource_type: str,
        resource_name: str,
    ) -&gt; ResourceModel:

        component = self.get_component(resource_state_uuid, component_name)

        resource = next(
            (
                x
                for x in component.resources
                if x.ruuid == resource_type and x.name == resource_name
            ),
            None,
        )

        if not resource:
            raise ResourceDoesNotExist(
                f&#34;Resource {resource_type}::{resource_name} does not exist in Component {component_name} in Resource State {resource_state_uuid}&#34;
            )

        return resource

    def get_resource_by_hash(
        self,
        resource_state_uuid: str,
        component_name: str,
        resource_type: str,
        resource_hash: str,
    ) -&gt; ResourceModel:

        component = self.get_component(resource_state_uuid, component_name)

        resource = next(
            (
                x
                for x in component.resources
                if x.ruuid == resource_type and x.hash == resource_hash
            ),
            None,
        )

        if not resource:
            raise ResourceDoesNotExist(
                f&#34;Resource {resource_type}::{resource_hash} does not exist in Component {component_name} in Resource State {resource_state_uuid}&#34;
            )

        return resource

    def get_cloud_output_value_by_name(
        self,
        resource_state_uuid: str,
        component_name: str,
        resource_type: str,
        resource_name: str,
        key: str,
    ) -&gt; Any:

        component = self.get_component(resource_state_uuid, component_name)
        resource = self.get_resource_by_name(
            resource_state_uuid, component_name, resource_type, resource_name
        )

        cloud_output_id = self._get_cloud_output_id(resource)

        if not cloud_output_id in component.cloud_output:

            raise CloudOutputDoesNotExist(
                f&#34;Can not find Cloud Output for {resource_type}::{resource_name} in Component {component_name} in Resource State {resource_state_uuid}&#34;
            )

        cloud_output = component.cloud_output.get(cloud_output_id)

        if not cloud_output:
            raise CloudOutputDoesNotExist(
                f&#34;None value for Cloud Output for {resource_type}::{resource_name} in Component {component_name} in Resource State {resource_state_uuid}&#34;
            )

        if not key in cloud_output:
            raise KeyNotInCloudOutput(
                f&#34;Can not find Key {key} in Cloud Output for {resource_type}::{resource_name} in Component {component_name} in Resource State {resource_state_uuid}&#34;
            )

        return cloud_output.get(key)

    def get_cloud_output_value_by_hash(
        self,
        resource_state_uuid: str,
        component_name: str,
        resource_type: str,
        resource_hash: str,
        key: str,
    ) -&gt; Any:

        component = self.get_component(resource_state_uuid, component_name)
        resource = self.get_resource_by_hash(
            resource_state_uuid, component_name, resource_type, resource_hash
        )

        cloud_output_id = self._get_cloud_output_id(resource)

        if not cloud_output_id in component.cloud_output:
            raise CloudOutputDoesNotExist(
                f&#34;Can not find Cloud Output for {resource_type}::{resource_hash} in Component {component_name} in Resource State {resource_state_uuid}&#34;
            )

        cloud_output = component.cloud_output.get(cloud_output_id)

        if not cloud_output:
            raise CloudOutputDoesNotExist(
                f&#34;None value for Cloud Output for {resource_type}::{resource_hash} in Component {component_name} in Resource State {resource_state_uuid}&#34;
            )

        if not key in cloud_output:
            raise KeyNotInCloudOutput(
                f&#34;Can not find Key {key} in Cloud Output for {resource_type}::{resource_hash} in Component {component_name} in Resource State {resource_state_uuid}&#34;
            )

        return cloud_output.get(key)


    def get_cloud_output_by_name(
        self,
        resource_state_uuid: str,
        component_name: str,
        resource_type: str,
        resource_name: str,
    ) -&gt; Any:

        component = self.get_component(resource_state_uuid, component_name)
        resource = self.get_resource_by_name(
            resource_state_uuid, component_name, resource_type, resource_name
        )

        cloud_output_id = self._get_cloud_output_id(resource)

        if not cloud_output_id in component.cloud_output:

            raise CloudOutputDoesNotExist(
                f&#34;Can not find Cloud Output for {resource_type}::{resource_name} in Component {component_name} in Resource State {resource_state_uuid}&#34;
            )

        cloud_output = component.cloud_output.get(cloud_output_id)

        return cloud_output

    def create_differences(
        self,
        resource_state_uuid: str,
        new_components: List[ComponentModel],
        old_components: List[str],
    ) -&gt; Tuple[
        Component_Difference, Resource_Reference_Difference, Resource_Difference
    ]:
        try:
            # Load the previous components
            previous_components: List[ComponentModel] = [
                self.get_component(resource_state_uuid, x) for x in old_components
            ]
           
        except Exception as e:
            raise e

        return _create_differences(new_components, previous_components)

    def _update_component(
        self,
        component: ComponentModel,
        diff: Resource_Difference,
        new_cloud_output: Dict = {},
        resolved_cloud_information: Dict={}
    ) -&gt; ComponentModel:
        &#34;&#34;&#34;
        Apply a resource difference over a component model and return the updated component model

        Arguments:
            component(ComponentModel): The component to update
            diff (Resource_Difference): The difference to apply
            new_cloud_output (Dict): The updated output if needed
            resolved_cloud_information (Dict): cloud output information used to deploy resource

        Returns:
            new_component(ComponentModel): The update component model

        &#34;&#34;&#34;
        if diff.action_type == Resource_Change_Type.DELETE:
            
            component.resources = [
                x
                for x in component.resources
                if not (x.ruuid == diff.previous_resource.ruuid and x.name == diff.previous_resource.name)
            ] 
            
            # remove the previous resource&#39;s cloud output
            previous_resource_cloud_output_id = self._get_cloud_output_id(
                diff.previous_resource
            )
            
            if previous_resource_cloud_output_id in component.cloud_output:
                component.cloud_output.pop(previous_resource_cloud_output_id)


            if previous_resource_cloud_output_id  in component.previous_resolved_cloud_values:
                component.previous_resolved_cloud_values.pop(previous_resource_cloud_output_id)
            

        elif (
            diff.action_type == Resource_Change_Type.UPDATE_IDENTITY
            or diff.action_type == Resource_Change_Type.UPDATE_NAME
        ):
                   
            component.resources = [
                x
                for x in component.resources
                if not (x.ruuid == diff.previous_resource.ruuid and x.name == diff.previous_resource.name)
            ]  +  [diff.new_resource]

            # remove the previous resource&#39;s cloud output
            previous_resource_cloud_output_id = self._get_cloud_output_id(
                diff.previous_resource
            )

            if previous_resource_cloud_output_id in component.cloud_output:
                component.cloud_output.pop(previous_resource_cloud_output_id)

            if previous_resource_cloud_output_id  in component.previous_resolved_cloud_values:
                component.previous_resolved_cloud_values.pop(previous_resource_cloud_output_id)
            
            cloud_output_id = self._get_cloud_output_id(diff.new_resource)
            component.cloud_output[cloud_output_id] = new_cloud_output

            component.previous_resolved_cloud_values[cloud_output_id] = resolved_cloud_information
        

        elif diff.action_type == Resource_Change_Type.CREATE:
            component.resources.append(diff.new_resource)            

            cloud_output_id = self._get_cloud_output_id(diff.new_resource)

            component.cloud_output[cloud_output_id] = new_cloud_output
            component.previous_resolved_cloud_values[cloud_output_id] = resolved_cloud_information

        # recompute hash
        component.hash = _compute_component_hash(component)

        return component

    def _get_cloud_output_id(self, resource: ResourceModel) -&gt; str:
        &#34;&#34;&#34;
        Uniform way of generating cloud mapping id&#39;s

        Arguments:
            resource (ResourceModel): resource to get id of

        Returns:
            cloud_output_id (str): id for the resource
        &#34;&#34;&#34;
        return f&#34;{resource.ruuid};{resource.name}&#34;

    def _get_resource_state_file_location(self, resource_state_uuid: str) -&gt; FilePath:
        return self._central_state.resource_state_locations.get(resource_state_uuid)


# Helper functions
def _compute_component_hash(component: ComponentModel) -&gt; str:
    &#34;&#34;&#34;
    Uniform way of computing a component&#39;s identity hash

    Argument:
        component (ComponentModel): The component to compute the hash of

    Returns:
        hash (str): identity hash for the component
    &#34;&#34;&#34;
    if component.resources:
        
        resources = [x for x in component.resources]
        resources.sort(key=lambda x: x.name)

        print([x.name for x in resources])
        print([x.hash for x in resources])
        resource_hashes = [x.hash for x in resources]
    else:
        resource_hashes = []

    if component.references:
        # TODO create hash of all the things
        references = [x for x in component.references]
        references.sort(key=lambda x: x.name)

        references_hashes = [x.name for x in references]
    else:
        references_hashes = []

    all_hashes = references_hashes + resource_hashes

    return cdev_hasher.hash_list(all_hashes)


def _create_resource_diffs(
    component_name: str,
    new_resources: List[ResourceModel],
    old_resource: List[ResourceModel],
) -&gt; List[Resource_Difference]:

    if old_resource:
        # build map&lt;hash,resource&gt;
        old_hash_to_resource: Dict[str, ResourceModel] = {
            x.hash: x for x in old_resource
        }
        # build map&lt;name,resource&gt;
        old_name_to_resource: Dict[str, ResourceModel] = {
            x.name: x for x in old_resource
        }
    else:
        old_hash_to_resource = {}
        old_name_to_resource = {}


    rv = []
    for resource in new_resources:
        if (
            resource.hash in old_hash_to_resource
            and resource.name in old_name_to_resource
        ):

            # POP the seen previous resources as we go so only remaining resources will be deletes
            old_resource.remove(old_hash_to_resource.get(resource.hash))
            continue

        elif (
            resource.hash in old_hash_to_resource
            and not resource.name in old_name_to_resource
        ):

            rv.append(
                Resource_Difference(
                    **{
                        &#34;action_type&#34;: Resource_Change_Type.UPDATE_NAME,
                        &#34;component_name&#34;: component_name,
                        &#34;previous_resource&#34;: old_hash_to_resource.get(resource.hash),
                        &#34;new_resource&#34;: resource,
                    }
                )
            )
            # POP the seen previous resources as we go so only remaining resources will be deletes
            old_resource.remove(old_hash_to_resource.get(resource.hash))

        elif (
            not resource.hash in old_hash_to_resource
            and resource.name in old_name_to_resource
        ):

            rv.append(
                Resource_Difference(
                    **{
                        &#34;action_type&#34;: Resource_Change_Type.UPDATE_IDENTITY,
                        &#34;component_name&#34;: component_name,
                        &#34;previous_resource&#34;: old_name_to_resource.get(resource.name),
                        &#34;new_resource&#34;: resource,
                    }
                )
            )
            # POP the seen previous resources as we go so only remaining resources will be deletes
            old_resource.remove(old_name_to_resource.get(resource.name))

        elif (
            not resource.hash in old_hash_to_resource
            and not resource.name in old_name_to_resource
        ):
            
            rv.append(
                Resource_Difference(
                    **{
                        &#34;action_type&#34;: Resource_Change_Type.CREATE,
                        &#34;component_name&#34;: component_name,
                        &#34;previous_resource&#34;: None,
                        &#34;new_resource&#34;: resource,
                    }
                )
            )

    if old_resource:
        for resource in old_resource:
           
            rv.append(
                Resource_Difference(
                    **{
                        &#34;action_type&#34;: Resource_Change_Type.DELETE,
                        &#34;component_name&#34;: component_name,
                        &#34;previous_resource&#34;: resource,
                        &#34;new_resource&#34;: None,
                    }
                )
            )

    return rv


def _create_reference_diffs(
    new_references: List[ResourceReferenceModel],
    old_references: List[ResourceReferenceModel],
    originating_component_name: str, 
) -&gt; List[Resource_Reference_Difference]:

    if old_references:
        # build map&lt;name,resource&gt;
        old_name_to_references: Dict[str, ResourceReferenceModel] = {
            f&#34;{x.ruuid};;{x.name}&#34;: x for x in old_references
        }
    else:
        old_name_to_references = {}

    rv = []
    for reference in new_references:
        _id = f&#34;{reference.ruuid};;{reference.name}&#34;
        if _id in old_name_to_references:
            # POP the seen previous resources as we go so only remaining resources will be deletes
            old_references.remove(old_name_to_references.get(_id))

        else:
            rv.append(
                Resource_Reference_Difference(
                    Resource_Reference_Change_Type.CREATE, originating_component_name, reference
                )
            )

    for old_reference in old_references:
        
        rv.append(
            Resource_Reference_Difference(
                Resource_Reference_Change_Type.DELETE, originating_component_name, old_reference
            )
        )

    return rv


def _create_differences(
    new_components: List[ComponentModel], previous_components: List[ComponentModel]
) -&gt; Tuple[
    List[Component_Difference],
    List[Resource_Difference],
    List[Resource_Reference_Difference]
]:

    component_diffs = []
    resource_diffs = []
    reference_diffs = []

    if previous_components:
        # build map&lt;hash,resource&gt;
        previous_hash_to_component = {x.hash: x for x in previous_components}
        # build map&lt;name,resource&gt;
        previous_name_to_component = {x.name: x for x in previous_components}
        previous_components_to_remove = [x for x in previous_components]
    else:
        previous_hash_to_component = {}
        previous_name_to_component = {}
        previous_components_to_remove = []

    if new_components:
        for component in new_components:

            if (
                not component.hash in previous_hash_to_component
                and not component.name in previous_name_to_component
            ):
                # Create component and all resources and all references
            
                component_diffs.append(
                    Component_Difference(
                        Component_Change_Type.CREATE, new_name=component.name
                    )
                )

                tmp_resource_diff = _create_resource_diffs(
                    component.name, component.resources, []
                )
                resource_diffs.extend(tmp_resource_diff)

                tmp_reference_diff = _create_reference_diffs(component.references, [], component.name)
                reference_diffs.extend(tmp_reference_diff)

            elif (
                component.hash in previous_hash_to_component
                and component.name in previous_name_to_component
            ):
                # Since the hash is the same we can infer all the resource hashes and reference hashes are the same
                # Even though the hash has remained the same we need to check for name changes in the resources
                previous_component = previous_name_to_component.get(component.name)

                # Should only output resource name changes
                tmp_resource_diff = _create_resource_diffs(
                    component.name, component.resources, previous_component.resources
                )

                if any(
                    [
                        not x.action_type == Resource_Change_Type.UPDATE_NAME
                        for x in tmp_resource_diff
                    ]
                ):
                    # if there is a resource change that is not an update name raise an exception
                    raise Exception

                resource_diffs.extend(tmp_resource_diff)

                # POP the seen previous component as we go so only remaining resources will be deletes
                previous_components_to_remove.remove(previous_component)

            elif (
                component.hash in previous_hash_to_component
                and not component.name in previous_name_to_component
            ):
                # hash of the component has stayed the same but the user has renamed the component name
                # Even though the hash has remained the same we need to check for name changes in the resources
                previous_component = previous_hash_to_component.get(component.hash)

                component_diffs.append(
                    Component_Difference(
                        Component_Change_Type.UPDATE_NAME,
                        previous_name=previous_component.name,
                        new_name=component.name,
                    )
                )

                # Should only output resource name changes
                tmp_resource_diff = _create_resource_diffs(
                    component.name, component.resources, previous_component.resources
                )

                if any(
                    [
                        not x.action_type == Resource_Change_Type.UPDATE_NAME
                        for x in tmp_resource_diff
                    ]
                ):
                    # if there is a resource change that is not an update name raise an exception
                    raise Exception

                resource_diffs.extend(tmp_resource_diff)

                # POP the seen previous component as we go so only remaining resources will be deletes
                previous_components_to_remove.remove(previous_component)

            elif (
                not component.hash in previous_hash_to_component
                and component.name in previous_name_to_component
            ):
                # hash of the component has changed but not the name
                # This means a resource or reference has updated its identity hash
                previous_component = previous_name_to_component.get(component.name)

                tmp_resource_diff = _create_resource_diffs(
                    component.name, component.resources, previous_component.resources
                )
                resource_diffs.extend(tmp_resource_diff)

                tmp_reference_diff = _create_reference_diffs(
                    component.references, previous_component.references, component.name
                )
                reference_diffs.extend(tmp_reference_diff)

                component_diffs.append(
                    Component_Difference(
                        Component_Change_Type.UPDATE_IDENTITY,
                        previous_name=previous_component.name,
                        new_name=component.name,
                    )
                )

                # POP the seen previous component as we go so only remaining resources will be deletes
                previous_components_to_remove.remove(previous_component)

    for removed_component in previous_components_to_remove:

        component_diffs.append(
            Component_Difference(
                Component_Change_Type.DELETE,
                previous_name=removed_component.name,
            )
        )

        tmp_resource_diff = _create_resource_diffs(
            removed_component.name, [], removed_component.resources
        )
        resource_diffs.extend(tmp_resource_diff)

        tmp_reference_diff = _create_reference_diffs([], removed_component.references, removed_component.name)
        reference_diffs.extend(tmp_reference_diff)

    return component_diffs, resource_diffs, reference_diffs</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="core.default.backend.CanNotFindResourceStateFile"><code class="flex name class">
<span>class <span class="ident">CanNotFindResourceStateFile</span></span>
<span>(</span><span>msg:str, nested_exceptions:Exception=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CanNotFindResourceStateFile(LocalBackendError):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a class="" title="core.default.backend.LocalBackendError" href="#core.default.backend.LocalBackendError">LocalBackendError</a></li>
<li><a class="" title="core.constructs.backend_exceptions.BackendError" href="../constructs/backend_exceptions.html#core.constructs.backend_exceptions.BackendError">BackendError</a></li>
<li><a class="" title="core.utils.exceptions.Cdev_Error" href="../utils/exceptions.html#core.utils.exceptions.Cdev_Error">Cdev_Error</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="core.default.backend.InvalidResourceStateData"><code class="flex name class">
<span>class <span class="ident">InvalidResourceStateData</span></span>
<span>(</span><span>msg:str, nested_exceptions:Exception=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InvalidResourceStateData(LocalBackendError):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a class="" title="core.default.backend.LocalBackendError" href="#core.default.backend.LocalBackendError">LocalBackendError</a></li>
<li><a class="" title="core.constructs.backend_exceptions.BackendError" href="../constructs/backend_exceptions.html#core.constructs.backend_exceptions.BackendError">BackendError</a></li>
<li><a class="" title="core.utils.exceptions.Cdev_Error" href="../utils/exceptions.html#core.utils.exceptions.Cdev_Error">Cdev_Error</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="core.default.backend.LocalBackend"><code class="flex name class">
<span>class <span class="ident">LocalBackend</span></span>
<span>(</span><span>base_folder:pydantic.types.DirectoryPath, central_state_file:pydantic.types.FilePath=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of a Backend using locally stored json files as the peristent storage medium. This backend should only be used for small project as it does not provide any mechanisms
to work well when multiple people edit the state. Also this is a single threaded implementation.</p>
<p><strong><em> For now, we will not use any kind of WAL for make changes to underlying state files, so it can be bad if you kill the process unexpectedly. In the future, it will use some mechanism
to prevent this. </em></strong></p>
<h2 id="arguments">Arguments</h2>
<p>base_folder (DirectoryPath): Path to a folder to use for storing local json files. Defaults to cdev setting if not provided.
central_state_file (FilePath): Path to the central state file. Defaults to cdev setting if not provided.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LocalBackend(Backend):
    # Structurally, this implementation will have a central json that can be used as an index into more precise json files. For example, each resource state will be its own json file, but
    # the central file will keep track of each one.
    def __init__(
        self, base_folder: DirectoryPath, central_state_file: FilePath = None
    ) -&gt; None:
        &#34;&#34;&#34;
        Implementation of a Backend using locally stored json files as the peristent storage medium. This backend should only be used for small project as it does not provide any mechanisms
        to work well when multiple people edit the state. Also this is a single threaded implementation.

        *** For now, we will not use any kind of WAL for make changes to underlying state files, so it can be bad if you kill the process unexpectedly. In the future, it will use some mechanism
        to prevent this. ***

        Arguments:
            base_folder (DirectoryPath): Path to a folder to use for storing local json files. Defaults to cdev setting if not provided.
            central_state_file (FilePath): Path to the central state file. Defaults to cdev setting if not provided.
        &#34;&#34;&#34;

        
        DEFAULT_CENTRAL_STATE_FILE = os.path.join(base_folder, &#34;local_state.json&#34;)


        self.base_folder = base_folder
        self.central_state_file = (
            central_state_file if central_state_file else DEFAULT_CENTRAL_STATE_FILE
        )

        if not os.path.isdir(self.base_folder):
            print(f&#34;ERROR HERE&#34;)
            raise Exception

        if not os.path.isfile(self.central_state_file):
            self._central_state = LocalCentralFile({}, [], [])

        else:
            with open(self.central_state_file, &#34;r&#34;) as fh:
                self._central_state = LocalCentralFile(**json.load(fh))

    def _write_central_file(self):
        file_manager.safe_json_write(self._central_state.dict(), self.central_state_file)

    def _write_resource_state_file(self, resource_state: Resource_State, fp: FilePath):
        file_manager.safe_json_write(resource_state.dict(), fp)
    

    # Api for working with Resource States
    def create_resource_state(
        self, name: str, parent_resource_state_uuid: str = None
    ) -&gt; str:
        # Create the new resource state
        if name in set(self._central_state.resource_state_names):
            raise ResourceStateAlreadyExists(&#34;Creating resource state with taken name&#34;)

        resource_state_uuid = str(uuid.uuid4())
        if not parent_resource_state_uuid:
            # Create this as a top level resource state
            new_resource_state = Resource_State(name, resource_state_uuid)
            self._central_state.top_level_states.append(new_resource_state.uuid)

        else:
            new_resource_state = Resource_State(
                name=name,
                uuid=resource_state_uuid,
                components=[],
                parent_uuid=parent_resource_state_uuid,
            )

        filename = os.path.join(
            self.base_folder, f&#34;resource_state_{new_resource_state.uuid}.json&#34;
        )

        self._central_state.resource_state_locations[new_resource_state.uuid] = filename
        self._central_state.resource_state_names.append(new_resource_state.name)

        self._write_central_file()
        self._write_resource_state_file(new_resource_state, filename)

        return new_resource_state.uuid

    def delete_resource_state(self, resource_state_uuid: str):
        if not resource_state_uuid in self._central_state.resource_state_locations:
            raise ResourceStateDoesNotExist(
                f&#34;Resource state: {resource_state_uuid} does not exist&#34;
            )

        resource_state_to_delete = self.get_resource_state(resource_state_uuid)

        if resource_state_to_delete.children:
            # Can not delete resource state with children
            raise ResourceStateNotEmpty(&#34;Resource state has child resource states&#34;)

        if not len(resource_state_to_delete.components) == 0:
            # Can not delete a non empty resource state
            raise ResourceStateNotEmpty(&#34;Resource state has components&#34;)

        if resource_state_to_delete.parent_uuid:
            # Need to remove this as child of parent
            pass

        else:
            # if the resource state had no parent, then it was a top level resource state
            self._central_state.top_level_states.remove(resource_state_to_delete.uuid)

        self._central_state.resource_state_names.remove(resource_state_to_delete.name)
        file_location = self._central_state.resource_state_locations.pop(
            resource_state_to_delete.uuid
        )

        self._write_central_file()
        os.remove(file_location)

    def get_resource_state(self, resource_state_uuid: str) -&gt; Resource_State:
        if not resource_state_uuid in self._central_state.resource_state_locations:
            raise ResourceStateDoesNotExist(
                f&#34;Resource State: {resource_state_uuid} does not exists&#34;
            )

        file_location = self._central_state.resource_state_locations.get(
            resource_state_uuid
        )

        if not os.path.isfile(file_location):
            raise CanNotFindResourceStateFile(
                f&#34;Can not find resource state file for {resource_state_uuid}&#34;
            )

        try:
            return file_manager.load_resource_state(file_location)


        except Exception as e:
            raise InvalidResourceStateData(
                f&#34;Ivalid data for Resource State from file {file_location} for resource state {resource_state_uuid}; {e}&#34;
            )

    def get_top_level_resource_states(self) -&gt; List[Resource_State]:
        rv = []
        
        for resource_id in self._central_state.top_level_states:
            # Let any exception from loading a state pass up to caller
            rv.append(self.get_resource_state(resource_id))

        
        return rv

    # Components
    def _create_component(self, resource_state_uuid: str, component_name: str):

        resource_state = self.get_resource_state(resource_state_uuid)
        resource_state_file_location = self._get_resource_state_file_location(
            resource_state_uuid
        )

        if component_name in set(x.name for x in resource_state.components):
            # Cant not have two components of the same name in the same resource state
            raise ComponentAlreadyExists(
                f&#34;Component already exists with name {component_name} in Resource State {resource_state_uuid}&#34;
            )

        # Create the new component
        new_component = ComponentModel(component_name)
        resource_state.components.append(new_component)

        # Create a uuid for the component
        component_uuid = str(uuid.uuid4())
        resource_state.component_name_to_uuid[component_name] = component_uuid

        self._write_resource_state_file(resource_state, resource_state_file_location)

    def _delete_component(self, resource_state_uuid: str, component_name: str):

        resource_state = self.get_resource_state(resource_state_uuid)
        resource_state_file_location = self._get_resource_state_file_location(
            resource_state_uuid
        )

        if not component_name in set(x.name for x in resource_state.components):
            # Component of that name does not exists
            raise ComponentDoesNotExist(
                f&#34;Could not find component {component_name} in Resource State {resource_state_uuid}&#34;
            )

        deleteing_component = next(
            x for x in resource_state.components if x.name == component_name
        )

        if not len(deleteing_component.resources) == 0:
            raise ComponentNotEmpty(
                f&#34;Can not delete Component {component_name} in Resource State {resource_state_uuid} because the component is not empty&#34;
            )

        resource_state.components = [
            x for x in resource_state.components if not x.name == component_name
        ]

        
        resource_state.component_name_to_uuid.pop(component_name)

        self._write_resource_state_file(resource_state, resource_state_file_location)


    def _update_component_name(self, resource_state_uuid: str, previous_component_name: str, new_component_name: str):
        resource_state = self.get_resource_state(resource_state_uuid)
        resource_state_file_location = self._get_resource_state_file_location(
            resource_state_uuid
        )

        if not previous_component_name in set(x.name for x in resource_state.components) or not previous_component_name in resource_state.component_name_to_uuid:
            # Component of that name does not exists
            raise ComponentDoesNotExist(
                f&#34;Could not find component {previous_component_name} in Resource State {resource_state_uuid}&#34;
            )


        if new_component_name in set(x.name for x in resource_state.components) or new_component_name in resource_state.component_name_to_uuid:
            # Cant not have two components of the same name in the same resource state
            raise ComponentAlreadyExists(
                f&#34;Component already exists with name {new_component_name} in Resource State {resource_state_uuid}&#34;
            )

        # get the component to rename
        rename_component = next(
            x for x in resource_state.components if x.name == previous_component_name
        )

        # remove the component from the list of components
        resource_state.components = [
            x for x in resource_state.components if not x.name == previous_component_name
        ]

        # Since ComponentModels are frozen, we can just change the name
        # So we make a dict of the current ComponentModel then change the name and use the dict as input
        # for a new ComponentModel Obj. Then add the new Obj to the resource state
        component_as_dict = rename_component.dict()
        component_as_dict[&#39;name&#39;] = new_component_name
        new_component = ComponentModel(**component_as_dict)

        resource_state.components.append(new_component)

        # Update the name to uuid dict
        resource_state.component_name_to_uuid.pop(previous_component_name)
        resource_state.component_name_to_uuid[new_component_name] = new_component


        self._write_resource_state_file(resource_state, resource_state_file_location)

        

    def get_component(
        self, resource_state_uuid: str, component_name: str
    ) -&gt; ComponentModel:

        resource_state = self.get_resource_state(resource_state_uuid)

        if not component_name in set(x.name for x in resource_state.components):
            # Component of that name does not exists
            raise ComponentDoesNotExist(
                f&#34;Can not find Component {component_name} in Resource State {resource_state_uuid}&#34;
            )

        return next(x for x in resource_state.components if x.name == component_name)


    def get_component_uuid(self, resource_state_uuid: str, component_name: str) -&gt; str:
        resource_state = self.get_resource_state(resource_state_uuid)

        if not component_name in resource_state.component_name_to_uuid:
            raise ComponentDoesNotExist(
                f&#34;Can not find Component {component_name} in Resource State {resource_state_uuid}&#34;
            )

        component_uuid = resource_state.component_name_to_uuid.get(component_name)

        return cdev_hasher.hash_list([resource_state_uuid, component_uuid])


    def update_component(
        self, resource_state_uuid: str, component_difference: Component_Difference
    ):
        if component_difference.action_type == Component_Change_Type.CREATE:
            self._create_component(resource_state_uuid , component_difference.new_name)
            return

        elif component_difference.action_type == Component_Change_Type.DELETE:
            self._delete_component(resource_state_uuid, component_difference.previous_name)
            return

        elif component_difference.action_type == Component_Change_Type.UPDATE_IDENTITY:
            return

        elif  component_difference.action_type == Component_Change_Type.UPDATE_NAME:
            self._update_component_name(resource_state_uuid, component_difference.previous_name, component_difference.new_name)

        else:
            raise Exception(f&#34;Component Action type not supported {component_difference.action_type}&#34;)


    def create_resource_change_transaction(
        self, resource_state_uuid: str, component_name: str, diff: Resource_Difference
    ) -&gt; Tuple[str, str]:
        resource_state = self.get_resource_state(resource_state_uuid)
        resource_state_file_location = self._get_resource_state_file_location(
            resource_state_uuid
        )

        transaction_token = str(uuid.uuid4())

        ruuid = diff.new_resource.ruuid if diff.new_resource else diff.previous_resource.ruuid

        namespace_token = cdev_hasher.hash_list([resource_state_uuid, self.get_component_uuid(resource_state_uuid, component_name), ruuid])

        resource_state.resource_changes[transaction_token] = (component_name, diff)

        self._write_resource_state_file(resource_state, resource_state_file_location)

        return transaction_token, namespace_token


    def complete_resource_change(
        self,
        resource_state_uuid: str,
        component_name: str,
        diff: Resource_Difference,
        transaction_token: str,
        cloud_output: Dict = None,
        resolved_cloud_information: Dict={}
    ):

        resource_state = self.get_resource_state(resource_state_uuid)
        resource_state_file_location = self._get_resource_state_file_location(
            resource_state_uuid
        )

        
        if not transaction_token in resource_state.resource_changes:
            
            raise ResourceChangeTransactionDoesNotExist(
                f&#34;Transaction {transaction_token} does not exist in Resource State {resource_state_uuid}&#34;
            )

        component = self.get_component(resource_state_uuid, component_name)
        
        new_component = self._update_component(component, diff, cloud_output, resolved_cloud_information)
        
        
        resource_state.components = [
            x for x in resource_state.components if not x.name == component.name
        ] + [new_component]

        resource_state.resource_changes.pop(transaction_token)

        self._write_resource_state_file(resource_state, resource_state_file_location)
        

    def fail_resource_change(
        self,
        resource_state_uuid: str,
        component_name: str,
        diff: Resource_Difference,
        transaction_token: str,
        failed_state: Dict,
    ):

        resource_state = self.get_resource_state(resource_state_uuid)
        resource_state_file_location = self._get_resource_state_file_location(
            resource_state_uuid
        )

        if not transaction_token in resource_state.resource_changes:
            raise ResourceChangeTransactionDoesNotExist(
                f&#34;Transaction {transaction_token} does not exist in Resource State {resource_state_uuid}&#34;
            )

        resource_state.resource_changes.pop(transaction_token)
        resource_state.failed_changes[transaction_token] = (
            component_name,
            diff,
            failed_state,
        )

        self._write_resource_state_file(resource_state, resource_state_file_location)

    def change_failed_state_of_resource_change(
        self, resource_state_uuid: str, transaction_token: str, new_failed_state: Dict
    ):

        resource_state = self.get_resource_state(resource_state_uuid)
        resource_state_file_location = self._get_resource_state_file_location(
            resource_state_uuid
        )

        if not transaction_token in resource_state.failed_changes:
            raise ResourceChangeTransactionDoesNotExist(
                f&#34;Transaction {transaction_token} does not exist in Resource State {resource_state_uuid}&#34;
            )

        previous_component_name, previous_diff, _ = resource_state.failed_changes.get(
            transaction_token
        )

        resource_state.failed_changes[transaction_token] = (
            previous_component_name,
            previous_diff,
            new_failed_state,
        )

        self._write_resource_state_file(resource_state, resource_state_file_location)

    def recover_failed_resource_change(
        self,
        resource_state_uuid: str,
        transaction_token: str,
        to_previous_state: bool = True,
        cloud_output: Dict = None,
    ):

        resource_state = self.get_resource_state(resource_state_uuid)
        resource_state_file_location = self._get_resource_state_file_location(
            resource_state_uuid
        )

        if not transaction_token in resource_state.failed_changes:
            raise ResourceChangeTransactionDoesNotExist(
                f&#34;Transaction {transaction_token} does not exist in Resource State {resource_state_uuid}&#34;
            )

        component_name, diff, _ = resource_state.failed_changes.pop(transaction_token)

        if not to_previous_state:
            component = self.get_component(component_name)

            new_component = self._update_component(component, diff, cloud_output)

            resource_state.components = [
                x for x in resource_state.components if not x.name == component_name
            ] + [new_component]

        self._write_resource_state_file(resource_state, resource_state_file_location)

    def remove_failed_resource_change(
        self, resource_state_uuid: str, transaction_token: str
    ):

        resource_state = self.get_resource_state(resource_state_uuid)
        resource_state_file_location = self._get_resource_state_file_location(
            resource_state_uuid
        )

        if not transaction_token in resource_state.failed_changes:
            raise ResourceChangeTransactionDoesNotExist(
                f&#34;Transaction {transaction_token} does not exist in Resource State {resource_state_uuid}&#34;
            )

        resource_state.failed_changes.pop(transaction_token)

        self._write_resource_state_file(resource_state, resource_state_file_location)

    def resolve_reference_change(
        self,
        resource_state_uuid: str,
        diff: Resource_Reference_Difference,
    ):
        resource_state = self.get_resource_state(resource_state_uuid)
        resource_state_file_location = self._get_resource_state_file_location(
            resource_state_uuid
        )

        component = self.get_component(resource_state_uuid, diff.originating_component_name)

        _reference_resource_state = resource_state
        if diff.resource_reference.is_in_parent_resource_state:
            if not resource_state.parent_uuid:
                raise ResourceReferenceError(
                    f&#34;Current Resource State {resource_state_uuid} does not have a Parent Resource State to resolve {diff} to&#34;
                )

            _reference_resource_state = self.get_resource_state(
                resource_state.parent_uuid
            )

        try:
            _referenced_component = self.get_component(
                _reference_resource_state.uuid, diff.resource_reference.component_name
            )
        except ComponentDoesNotExist:
            raise ResourceReferenceError(
                f&#34;Resource State {_reference_resource_state.uuid} does not contain component {diff.resource_reference.component_name} for {diff}&#34;
            )

        all_parent_resources = set(
            [f&#34;{x.ruuid}{x.name}&#34; for x in _referenced_component.resources]
        )

        if (
            not f&#34;{diff.resource_reference.ruuid}{diff.resource_reference.name}&#34;
            in all_parent_resources
        ):
            raise ResourceReferenceError(
                f&#34;Could not find resource {diff.resource_reference.ruuid};{diff.resource_reference.name} in parent component&#34;
            )

        if diff.action_type == Resource_Reference_Change_Type.CREATE:
            
            reference_id = (
                f&#34;{diff.resource_reference.ruuid}{diff.resource_reference.name}&#34;
            )

            # resolve the reference by adding a count to the reference counter in the referenced component
            if not reference_id in _referenced_component.external_references:
                _referenced_component.external_references[reference_id] = {&#34;cnt&#34;: 1}

            else:
                previous_cnt = _referenced_component.external_references[
                    reference_id
                ].get(&#34;cnt&#34;)
                _referenced_component.external_references[reference_id] = {
                    &#34;cnt&#34;: previous_cnt + 1
                }

            # Add this to the references for this component
            component.references.append(diff.resource_reference)

        elif diff.action_type == Resource_Reference_Change_Type.DELETE:
            
            reference_id = (
                f&#34;{diff.resource_reference.ruuid}{diff.resource_reference.name}&#34;
            )

            # resolve the dereference by subtracting a count to the reference counter in the referenced component
            if not reference_id in _referenced_component.external_references:
                raise ResourceReferenceError(
                    f&#34;Trying to deference resource that does not have reference info&#34;
                )

            else:
                previous_cnt = _referenced_component.external_references[
                    reference_id
                ].get(&#34;cnt&#34;)
                _referenced_component.external_references[reference_id] = {
                    &#34;cnt&#34;: previous_cnt - 1
                }

            if _referenced_component.external_references[reference_id] == 0:
                _referenced_component.external_references.pop(reference_id)

            # Pop this references for this component
            component.references.remove(diff.resource_reference)

        _reference_resource_state.components = [
            x
            for x in resource_state.components
            if not x.name == _referenced_component.name
        ] + [_referenced_component]
        resource_state.components = [
            x for x in resource_state.components if not x.name == component.name
        ] + [component]

        if diff.resource_reference.is_in_parent_resource_state:
            # if the reference is from the parent resource state then we need to update it so that it knows that the reference was resolved
            _reference_resource_state_fp = self._get_resource_state_file_location(
                _reference_resource_state.uuid
            )

            self._write_resource_state_file(
                _reference_resource_state, _reference_resource_state_fp
            )

        self._write_resource_state_file(resource_state, resource_state_file_location)

    # Get resources and cloud output
    def get_resource_by_name(
        self,
        resource_state_uuid: str,
        component_name: str,
        resource_type: str,
        resource_name: str,
    ) -&gt; ResourceModel:

        component = self.get_component(resource_state_uuid, component_name)

        resource = next(
            (
                x
                for x in component.resources
                if x.ruuid == resource_type and x.name == resource_name
            ),
            None,
        )

        if not resource:
            raise ResourceDoesNotExist(
                f&#34;Resource {resource_type}::{resource_name} does not exist in Component {component_name} in Resource State {resource_state_uuid}&#34;
            )

        return resource

    def get_resource_by_hash(
        self,
        resource_state_uuid: str,
        component_name: str,
        resource_type: str,
        resource_hash: str,
    ) -&gt; ResourceModel:

        component = self.get_component(resource_state_uuid, component_name)

        resource = next(
            (
                x
                for x in component.resources
                if x.ruuid == resource_type and x.hash == resource_hash
            ),
            None,
        )

        if not resource:
            raise ResourceDoesNotExist(
                f&#34;Resource {resource_type}::{resource_hash} does not exist in Component {component_name} in Resource State {resource_state_uuid}&#34;
            )

        return resource

    def get_cloud_output_value_by_name(
        self,
        resource_state_uuid: str,
        component_name: str,
        resource_type: str,
        resource_name: str,
        key: str,
    ) -&gt; Any:

        component = self.get_component(resource_state_uuid, component_name)
        resource = self.get_resource_by_name(
            resource_state_uuid, component_name, resource_type, resource_name
        )

        cloud_output_id = self._get_cloud_output_id(resource)

        if not cloud_output_id in component.cloud_output:

            raise CloudOutputDoesNotExist(
                f&#34;Can not find Cloud Output for {resource_type}::{resource_name} in Component {component_name} in Resource State {resource_state_uuid}&#34;
            )

        cloud_output = component.cloud_output.get(cloud_output_id)

        if not cloud_output:
            raise CloudOutputDoesNotExist(
                f&#34;None value for Cloud Output for {resource_type}::{resource_name} in Component {component_name} in Resource State {resource_state_uuid}&#34;
            )

        if not key in cloud_output:
            raise KeyNotInCloudOutput(
                f&#34;Can not find Key {key} in Cloud Output for {resource_type}::{resource_name} in Component {component_name} in Resource State {resource_state_uuid}&#34;
            )

        return cloud_output.get(key)

    def get_cloud_output_value_by_hash(
        self,
        resource_state_uuid: str,
        component_name: str,
        resource_type: str,
        resource_hash: str,
        key: str,
    ) -&gt; Any:

        component = self.get_component(resource_state_uuid, component_name)
        resource = self.get_resource_by_hash(
            resource_state_uuid, component_name, resource_type, resource_hash
        )

        cloud_output_id = self._get_cloud_output_id(resource)

        if not cloud_output_id in component.cloud_output:
            raise CloudOutputDoesNotExist(
                f&#34;Can not find Cloud Output for {resource_type}::{resource_hash} in Component {component_name} in Resource State {resource_state_uuid}&#34;
            )

        cloud_output = component.cloud_output.get(cloud_output_id)

        if not cloud_output:
            raise CloudOutputDoesNotExist(
                f&#34;None value for Cloud Output for {resource_type}::{resource_hash} in Component {component_name} in Resource State {resource_state_uuid}&#34;
            )

        if not key in cloud_output:
            raise KeyNotInCloudOutput(
                f&#34;Can not find Key {key} in Cloud Output for {resource_type}::{resource_hash} in Component {component_name} in Resource State {resource_state_uuid}&#34;
            )

        return cloud_output.get(key)


    def get_cloud_output_by_name(
        self,
        resource_state_uuid: str,
        component_name: str,
        resource_type: str,
        resource_name: str,
    ) -&gt; Any:

        component = self.get_component(resource_state_uuid, component_name)
        resource = self.get_resource_by_name(
            resource_state_uuid, component_name, resource_type, resource_name
        )

        cloud_output_id = self._get_cloud_output_id(resource)

        if not cloud_output_id in component.cloud_output:

            raise CloudOutputDoesNotExist(
                f&#34;Can not find Cloud Output for {resource_type}::{resource_name} in Component {component_name} in Resource State {resource_state_uuid}&#34;
            )

        cloud_output = component.cloud_output.get(cloud_output_id)

        return cloud_output

    def create_differences(
        self,
        resource_state_uuid: str,
        new_components: List[ComponentModel],
        old_components: List[str],
    ) -&gt; Tuple[
        Component_Difference, Resource_Reference_Difference, Resource_Difference
    ]:
        try:
            # Load the previous components
            previous_components: List[ComponentModel] = [
                self.get_component(resource_state_uuid, x) for x in old_components
            ]
           
        except Exception as e:
            raise e

        return _create_differences(new_components, previous_components)

    def _update_component(
        self,
        component: ComponentModel,
        diff: Resource_Difference,
        new_cloud_output: Dict = {},
        resolved_cloud_information: Dict={}
    ) -&gt; ComponentModel:
        &#34;&#34;&#34;
        Apply a resource difference over a component model and return the updated component model

        Arguments:
            component(ComponentModel): The component to update
            diff (Resource_Difference): The difference to apply
            new_cloud_output (Dict): The updated output if needed
            resolved_cloud_information (Dict): cloud output information used to deploy resource

        Returns:
            new_component(ComponentModel): The update component model

        &#34;&#34;&#34;
        if diff.action_type == Resource_Change_Type.DELETE:
            
            component.resources = [
                x
                for x in component.resources
                if not (x.ruuid == diff.previous_resource.ruuid and x.name == diff.previous_resource.name)
            ] 
            
            # remove the previous resource&#39;s cloud output
            previous_resource_cloud_output_id = self._get_cloud_output_id(
                diff.previous_resource
            )
            
            if previous_resource_cloud_output_id in component.cloud_output:
                component.cloud_output.pop(previous_resource_cloud_output_id)


            if previous_resource_cloud_output_id  in component.previous_resolved_cloud_values:
                component.previous_resolved_cloud_values.pop(previous_resource_cloud_output_id)
            

        elif (
            diff.action_type == Resource_Change_Type.UPDATE_IDENTITY
            or diff.action_type == Resource_Change_Type.UPDATE_NAME
        ):
                   
            component.resources = [
                x
                for x in component.resources
                if not (x.ruuid == diff.previous_resource.ruuid and x.name == diff.previous_resource.name)
            ]  +  [diff.new_resource]

            # remove the previous resource&#39;s cloud output
            previous_resource_cloud_output_id = self._get_cloud_output_id(
                diff.previous_resource
            )

            if previous_resource_cloud_output_id in component.cloud_output:
                component.cloud_output.pop(previous_resource_cloud_output_id)

            if previous_resource_cloud_output_id  in component.previous_resolved_cloud_values:
                component.previous_resolved_cloud_values.pop(previous_resource_cloud_output_id)
            
            cloud_output_id = self._get_cloud_output_id(diff.new_resource)
            component.cloud_output[cloud_output_id] = new_cloud_output

            component.previous_resolved_cloud_values[cloud_output_id] = resolved_cloud_information
        

        elif diff.action_type == Resource_Change_Type.CREATE:
            component.resources.append(diff.new_resource)            

            cloud_output_id = self._get_cloud_output_id(diff.new_resource)

            component.cloud_output[cloud_output_id] = new_cloud_output
            component.previous_resolved_cloud_values[cloud_output_id] = resolved_cloud_information

        # recompute hash
        component.hash = _compute_component_hash(component)

        return component

    def _get_cloud_output_id(self, resource: ResourceModel) -&gt; str:
        &#34;&#34;&#34;
        Uniform way of generating cloud mapping id&#39;s

        Arguments:
            resource (ResourceModel): resource to get id of

        Returns:
            cloud_output_id (str): id for the resource
        &#34;&#34;&#34;
        return f&#34;{resource.ruuid};{resource.name}&#34;

    def _get_resource_state_file_location(self, resource_state_uuid: str) -&gt; FilePath:
        return self._central_state.resource_state_locations.get(resource_state_uuid)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a class="" title="core.constructs.backend.Backend" href="../constructs/backend.html#core.constructs.backend.Backend">Backend</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a class="" title="core.constructs.backend.Backend" href="../constructs/backend.html#core.constructs.backend.Backend">Backend</a></b></code>:
<ul class="hlist">
<li><code><a class="" title="core.constructs.backend.Backend.change_failed_state_of_resource_change" href="../constructs/backend.html#core.constructs.backend.Backend.change_failed_state_of_resource_change">change_failed_state_of_resource_change</a></code></li>
<li><code><a class="" title="core.constructs.backend.Backend.complete_resource_change" href="../constructs/backend.html#core.constructs.backend.Backend.complete_resource_change">complete_resource_change</a></code></li>
<li><code><a class="" title="core.constructs.backend.Backend.create_differences" href="../constructs/backend.html#core.constructs.backend.Backend.create_differences">create_differences</a></code></li>
<li><code><a class="" title="core.constructs.backend.Backend.create_resource_change_transaction" href="../constructs/backend.html#core.constructs.backend.Backend.create_resource_change_transaction">create_resource_change_transaction</a></code></li>
<li><code><a class="" title="core.constructs.backend.Backend.create_resource_state" href="../constructs/backend.html#core.constructs.backend.Backend.create_resource_state">create_resource_state</a></code></li>
<li><code><a class="" title="core.constructs.backend.Backend.delete_resource_state" href="../constructs/backend.html#core.constructs.backend.Backend.delete_resource_state">delete_resource_state</a></code></li>
<li><code><a class="" title="core.constructs.backend.Backend.fail_resource_change" href="../constructs/backend.html#core.constructs.backend.Backend.fail_resource_change">fail_resource_change</a></code></li>
<li><code><a class="" title="core.constructs.backend.Backend.get_cloud_output_by_name" href="../constructs/backend.html#core.constructs.backend.Backend.get_cloud_output_by_name">get_cloud_output_by_name</a></code></li>
<li><code><a class="" title="core.constructs.backend.Backend.get_cloud_output_value_by_hash" href="../constructs/backend.html#core.constructs.backend.Backend.get_cloud_output_value_by_hash">get_cloud_output_value_by_hash</a></code></li>
<li><code><a class="" title="core.constructs.backend.Backend.get_cloud_output_value_by_name" href="../constructs/backend.html#core.constructs.backend.Backend.get_cloud_output_value_by_name">get_cloud_output_value_by_name</a></code></li>
<li><code><a class="" title="core.constructs.backend.Backend.get_component" href="../constructs/backend.html#core.constructs.backend.Backend.get_component">get_component</a></code></li>
<li><code><a class="" title="core.constructs.backend.Backend.get_component_uuid" href="../constructs/backend.html#core.constructs.backend.Backend.get_component_uuid">get_component_uuid</a></code></li>
<li><code><a class="" title="core.constructs.backend.Backend.get_resource_by_hash" href="../constructs/backend.html#core.constructs.backend.Backend.get_resource_by_hash">get_resource_by_hash</a></code></li>
<li><code><a class="" title="core.constructs.backend.Backend.get_resource_by_name" href="../constructs/backend.html#core.constructs.backend.Backend.get_resource_by_name">get_resource_by_name</a></code></li>
<li><code><a class="" title="core.constructs.backend.Backend.get_resource_state" href="../constructs/backend.html#core.constructs.backend.Backend.get_resource_state">get_resource_state</a></code></li>
<li><code><a class="" title="core.constructs.backend.Backend.get_top_level_resource_states" href="../constructs/backend.html#core.constructs.backend.Backend.get_top_level_resource_states">get_top_level_resource_states</a></code></li>
<li><code><a class="" title="core.constructs.backend.Backend.recover_failed_resource_change" href="../constructs/backend.html#core.constructs.backend.Backend.recover_failed_resource_change">recover_failed_resource_change</a></code></li>
<li><code><a class="" title="core.constructs.backend.Backend.remove_failed_resource_change" href="../constructs/backend.html#core.constructs.backend.Backend.remove_failed_resource_change">remove_failed_resource_change</a></code></li>
<li><code><a class="" title="core.constructs.backend.Backend.resolve_reference_change" href="../constructs/backend.html#core.constructs.backend.Backend.resolve_reference_change">resolve_reference_change</a></code></li>
<li><code><a class="" title="core.constructs.backend.Backend.update_component" href="../constructs/backend.html#core.constructs.backend.Backend.update_component">update_component</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="core.default.backend.LocalBackendError"><code class="flex name class">
<span>class <span class="ident">LocalBackendError</span></span>
<span>(</span><span>msg:str, nested_exceptions:Exception=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LocalBackendError(BackendError):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a class="" title="core.constructs.backend_exceptions.BackendError" href="../constructs/backend_exceptions.html#core.constructs.backend_exceptions.BackendError">BackendError</a></li>
<li><a class="" title="core.utils.exceptions.Cdev_Error" href="../utils/exceptions.html#core.utils.exceptions.Cdev_Error">Cdev_Error</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a class="" title="core.default.backend.CanNotFindResourceStateFile" href="#core.default.backend.CanNotFindResourceStateFile">CanNotFindResourceStateFile</a></li>
<li><a class="" title="core.default.backend.InvalidResourceStateData" href="#core.default.backend.InvalidResourceStateData">InvalidResourceStateData</a></li>
</ul>
</dd>
<dt id="core.default.backend.LocalCentralFile"><code class="flex name class">
<span>class <span class="ident">LocalCentralFile</span></span>
<span>(</span><span>resource_state_locations:Dict[str,str], top_level_states:List[str], resource_state_names:List[str])</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LocalCentralFile(BaseModel):
    resource_state_locations: Dict[str, str]  # uuid -&gt; file location
    top_level_states: List[str]  # uuid
    resource_state_names: List[str]

    def __init__(
        __pydantic_self__,
        resource_state_locations: Dict[str, str],
        top_level_states: List[str],
        resource_state_names: List[str],
    ) -&gt; None:
        super().__init__(
            **{
                &#34;resource_state_locations&#34;: resource_state_locations,
                &#34;top_level_states&#34;: top_level_states,
                &#34;resource_state_names&#34;: resource_state_names,
            }
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="core.default.backend.LocalCentralFile.resource_state_locations"><code class="name">var <span class="ident">resource_state_locations</span> :Dict[str,str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="core.default.backend.LocalCentralFile.resource_state_names"><code class="name">var <span class="ident">resource_state_names</span> :List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="core.default.backend.LocalCentralFile.top_level_states"><code class="name">var <span class="ident">top_level_states</span> :List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="core.default.backend.Local_Backend_Configuration"><code class="flex name class">
<span>class <span class="ident">Local_Backend_Configuration</span></span>
<span>(</span><span>config:Dict[~KT,~VT])</span>
</code></dt>
<dd>
<div class="desc"><p>Represents the data needed to create a new cdev workspace:</p>
<h2 id="parameters">Parameters</h2>
<p>python_module: The name of the python module to load as the backend
config: configuration option for the backend</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Local_Backend_Configuration(Backend_Configuration):
    def __init__(self, config: Dict) -&gt; None:
        &#34;&#34;&#34;
        Represents the data needed to create a new cdev workspace:

        Parameters:
            python_module: The name of the python module to load as the backend
            config: configuration option for the backend

        &#34;&#34;&#34;

        super().__init__(
            **{
                &#34;python_module&#34;: &#34;core.default.backend&#34;,
                &#34;python_class&#34;: &#34;LocalBackend&#34;,
                &#34;config&#34;: config,
            }
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a class="" title="core.constructs.backend.Backend_Configuration" href="../constructs/backend.html#core.constructs.backend.Backend_Configuration">Backend_Configuration</a></li>
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="core.default.backend.Local_Backend_Configuration.config"><code class="name">var <span class="ident">config</span> :Dict[~KT,~VT]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="core.default.backend.Local_Backend_Configuration.python_class"><code class="name">var <span class="ident">python_class</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="core.default.backend.Local_Backend_Configuration.python_module"><code class="name">var <span class="ident">python_module</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="core.default.backend.SetEncoder"><code class="flex name class">
<span>class <span class="ident">SetEncoder</span></span>
<span>(</span><span>*, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, sort_keys=False, indent=None, separators=None, default=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Extensible JSON <a href="http://json.org">http://json.org</a> encoder for Python data structures.</p>
<p>Supports the following objects and types by default:</p>
<p>+-------------------+---------------+
| Python
| JSON
|
+===================+===============+
| dict
| object
|
+-------------------+---------------+
| list, tuple
| array
|
+-------------------+---------------+
| str
| string
|
+-------------------+---------------+
| int, float
| number
|
+-------------------+---------------+
| True
| true
|
+-------------------+---------------+
| False
| false
|
+-------------------+---------------+
| None
| null
|
+-------------------+---------------+</p>
<p>To extend this to recognize other objects, subclass and implement a
<code>.default()</code> method with another method that returns a serializable
object for <code>o</code> if possible, otherwise it should call the superclass
implementation (to raise <code>TypeError</code>).</p>
<p>Constructor for JSONEncoder, with sensible defaults.</p>
<p>If skipkeys is false, then it is a TypeError to attempt
encoding of keys that are not str, int, float or None.
If
skipkeys is True, such items are simply skipped.</p>
<p>If ensure_ascii is true, the output is guaranteed to be str
objects with all incoming non-ASCII characters escaped.
If
ensure_ascii is false, the output can contain non-ASCII characters.</p>
<p>If check_circular is true, then lists, dicts, and custom encoded
objects will be checked for circular references during encoding to
prevent an infinite recursion (which would cause an OverflowError).
Otherwise, no such check takes place.</p>
<p>If allow_nan is true, then NaN, Infinity, and -Infinity will be
encoded as such.
This behavior is not JSON specification compliant,
but is consistent with most JavaScript based encoders and decoders.
Otherwise, it will be a ValueError to encode such floats.</p>
<p>If sort_keys is true, then the output of dictionaries will be
sorted by key; this is useful for regression tests to ensure
that JSON serializations can be compared on a day-to-day basis.</p>
<p>If indent is a non-negative integer, then JSON array
elements and object members will be pretty-printed with that
indent level.
An indent level of 0 will only insert newlines.
None is the most compact representation.</p>
<p>If specified, separators should be an (item_separator, key_separator)
tuple.
The default is (', ', ': ') if <em>indent</em> is <code>None</code> and
(',', ': ') otherwise.
To get the most compact JSON representation,
you should specify (',', ':') to eliminate whitespace.</p>
<p>If specified, default is a function that gets called for objects
that can't otherwise be serialized.
It should return a JSON encodable
version of the object or raise a <code>TypeError</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SetEncoder(json.JSONEncoder):
    def default(self, obj):
       if isinstance(obj, set):
          return list(obj)
       return json.JSONEncoder.default(self, obj)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>json.encoder.JSONEncoder</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="core.default.backend.SetEncoder.default"><code class="name flex">
<span>def <span class="ident">default</span></span>(<span>self, obj)</span>
</code></dt>
<dd>
<div class="desc"><p>Implement this method in a subclass such that it returns
a serializable object for <code>o</code>, or calls the base implementation
(to raise a <code>TypeError</code>).</p>
<p>For example, to support arbitrary iterators, you could
implement default like this::</p>
<pre><code>def default(self, o):
    try:
        iterable = iter(o)
    except TypeError:
        pass
    else:
        return list(iterable)
    # Let the base class default method raise the TypeError
    return JSONEncoder.default(self, o)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def default(self, obj):
   if isinstance(obj, set):
      return list(obj)
   return json.JSONEncoder.default(self, obj)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<img class='logo-img' src="https://s3.amazonaws.com/cdevframework.io/images/CoreLogo.svg" alt="site">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a class="sidebar" title="core.default" href="index.html">core.default</a></code></li>
</ul>
</li>
<li><h3><a class='nav-header' href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a class="sidebar" title="core.default.backend.CanNotFindResourceStateFile" href="#core.default.backend.CanNotFindResourceStateFile">CanNotFindResourceStateFile</a></code></h4>
</li>
<li>
<h4><code><a class="sidebar" title="core.default.backend.InvalidResourceStateData" href="#core.default.backend.InvalidResourceStateData">InvalidResourceStateData</a></code></h4>
</li>
<li>
<h4><code><a class="sidebar" title="core.default.backend.LocalBackend" href="#core.default.backend.LocalBackend">LocalBackend</a></code></h4>
</li>
<li>
<h4><code><a class="sidebar" title="core.default.backend.LocalBackendError" href="#core.default.backend.LocalBackendError">LocalBackendError</a></code></h4>
</li>
<li>
<h4><code><a class="sidebar" title="core.default.backend.LocalCentralFile" href="#core.default.backend.LocalCentralFile">LocalCentralFile</a></code></h4>
<ul >
<li><code><a class="sidebar" title="core.default.backend.LocalCentralFile.resource_state_locations" href="#core.default.backend.LocalCentralFile.resource_state_locations">resource_state_locations</a></code></li>
<li><code><a class="sidebar" title="core.default.backend.LocalCentralFile.resource_state_names" href="#core.default.backend.LocalCentralFile.resource_state_names">resource_state_names</a></code></li>
<li><code><a class="sidebar" title="core.default.backend.LocalCentralFile.top_level_states" href="#core.default.backend.LocalCentralFile.top_level_states">top_level_states</a></code></li>
</ul>
</li>
<li>
<h4><code><a class="sidebar" title="core.default.backend.Local_Backend_Configuration" href="#core.default.backend.Local_Backend_Configuration">Local_Backend_Configuration</a></code></h4>
<ul >
<li><code><a class="sidebar" title="core.default.backend.Local_Backend_Configuration.config" href="#core.default.backend.Local_Backend_Configuration.config">config</a></code></li>
<li><code><a class="sidebar" title="core.default.backend.Local_Backend_Configuration.python_class" href="#core.default.backend.Local_Backend_Configuration.python_class">python_class</a></code></li>
<li><code><a class="sidebar" title="core.default.backend.Local_Backend_Configuration.python_module" href="#core.default.backend.Local_Backend_Configuration.python_module">python_module</a></code></li>
</ul>
</li>
<li>
<h4><code><a class="sidebar" title="core.default.backend.SetEncoder" href="#core.default.backend.SetEncoder">SetEncoder</a></code></h4>
<ul >
<li><code><a class="sidebar" title="core.default.backend.SetEncoder.default" href="#core.default.backend.SetEncoder.default">default</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>