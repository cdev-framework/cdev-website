<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>core.utils.fs_manager.finder API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em;background:#EEE}#content{padding:20px}#sidebar{padding:30px;overflow:hidden;background:#07085d}#sidebar > *:last-child{margin-bottom:2cm}#sidebar::-webkit-scrollbar{width:8px}#sidebar::-webkit-scrollbar-track{border-radius:10px;background:#f1f1f100}#sidebar::-webkit-scrollbar-thumb{border-radius:10px;background:linear-gradient( 37deg,rgb(247,70,58) 1%,rgb(180,62,121) 80% )}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}a.sidebar{color:white;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#f7463a}a.nav-header{color:white}img.logo-img{display:block;margin-left:auto;margin-right:auto;width:25%}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#e0e0e0;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{height:100vh;overflow:auto;position:sticky;top:0;background:#07085d}#content{width:70%;max-width:200ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<!--<link rel="stylesheet"
href='https://cdevwebsitestaging.s3.amazonaws.com/bootstrap/css/bootstrap.min.css'>-->
<script href='/bootstrap/css/bootstrap.js'></script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>core.utils.fs_manager.finder</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from logging import raiseExceptions
import os
from pydantic import DirectoryPath
from pydantic.types import FilePath
from sortedcontainers.sortedlist import SortedKeyList
from typing import Dict, List, Tuple

from core.constructs.resource import (
    Resource,
    ResourceModel,
    ResourceReferenceModel,
    Resource_Reference,
)
from core.constructs.workspace import Workspace

from core.default.resources.simple.xlambda import (
    DependencyLayer,
    SimpleFunction,
    simple_function_model,
    SimpleFunctionConfiguration
)

from core.utils import hasher, module_loader, paths
from core.utils.logger import log

from serverless_parser import parser as serverless_parser


from . import writer
from . import package_mananger 


LAMBDA_LAYER_RUUID = &#34;cdev::simple::lambda_layer&#34;

def parse_folder(
    folder_path: DirectoryPath, 
) -&gt; Tuple[List[ResourceModel], List[ResourceReferenceModel]]:
    &#34;&#34;&#34;Search through the given folder looking for resource and references in Python files. 

    Args:
        folder_path (DirectoryPath): The directory to parse

    Returns:
        Tuple[
            List[ResourceModel],
            List[ResourceReferenceModel]
        ]
    
    Specifically, it loads all available python files and uses the loaded module to determine 
    the resources defined in the files. Any resource or reference defined in the global
    context of the file will be detected.
    
    Most resources are passed back as is, but there are optimizations performed on the `simple functions`. 
    Namely, Serverless functions are parsed to optimized the actual deployed artifact using the
    cparser library and then have their dependencies managed also.
    &#34;&#34;&#34;
    if not os.path.isdir(folder_path):
        raise Exception

    log.debug(&#34;Finding resources in folder %s&#34;, folder_path)

    python_files = [
        f
        for f in os.listdir(folder_path)
        if os.path.isfile(os.path.join(folder_path, f)) and f[-3:] == &#34;.py&#34;
    ]

    # [{&lt;resource&gt;}]
    resources_rv = SortedKeyList(key=lambda x: x.name)
    references_rv = SortedKeyList(key=lambda x: x.name)


    for pf in python_files:
        found_resources, found_references = _find_resources_information_from_file(
            os.path.join(folder_path, pf)
        )

        if found_resources:
            resources_rv.update(found_resources)

        if found_references:
            references_rv.update(found_references)

    # Any duplicate layers can be removed 
    cleaned_resources_rv = _deduplicate_layers_from_resource_list(resources_rv)

    return cleaned_resources_rv, references_rv


def _deduplicate_layers_from_resource_list(resources: List[Resource]) -&gt; List[Resource]:
    &#34;&#34;&#34;Remove duplicated layer resources

    Args:
        resources (List[Resource]): Sorted List of resources by x.hash

    Returns:
        resource (List[Resources]): List with duplicate layers removed

    Since multiple functions can produce the same Layer resource by referencing the same 
    3rd party resource, we need to deduplicate the layers from the list.
    &#34;&#34;&#34;

    for i in range(len(resources)):
        if i+1 &gt;= len(resources):
            break

        if not (resources[i].ruuid == LAMBDA_LAYER_RUUID and resources[i+1].ruuid == LAMBDA_LAYER_RUUID):
            continue

        if resources[i].hash == resources[i+1].hash:
            resources.pop(i)


    return resources

def _get_module_name_from_path(fp: FilePath):
    &#34;&#34;&#34;Convert a full file path of a python path into a importable module name

    Args:
        fp (FilePath): path to file

    Returns:
        str: The importable python module name 


    All module names will end up being relative to the workspace path. Note that this means
    the `Workspace` base path should be on the `Python Path`. This usually happens by default
    because the `Workspace` starts from the cwd. 
    &#34;&#34;&#34;
    relative_to_project_path = paths.get_relative_to_workspace_path(fp)

    relative_to_project_path_parts = relative_to_project_path.split(&#34;/&#34;)

    # If the last part of the file is __init__.pt then python will import it when the 
    # rest of the path is given without the last part
    if relative_to_project_path_parts[-1] == &#34;__init__.py&#34;:
        relative_to_project_path_parts.pop()
    else:
        # remove the .py part of the file name
        relative_to_project_path_parts[-1] = relative_to_project_path_parts[-1][:-3]

    # join the parts back with &#39;.&#39; to create the valid python module name
    full_module_path_from_project = &#34;.&#34;.join(relative_to_project_path_parts)

    return full_module_path_from_project


def _find_resources_information_from_file(
    fp: FilePath,
) -&gt; Tuple[List[ResourceModel], List[ResourceReferenceModel]]:
    &#34;&#34;&#34;Load a file and find top level objects that are Resources or References

    Args:
        fp (FilePath): path to python file

    Raises:
        Exception: [description]

    Returns:
        Tuple[List[ResourceModel], List[ResourceReferenceModel]]: Resources and References
    &#34;&#34;&#34;
    # Input: filepath
    if not os.path.isfile(fp):
        raise Exception

    if not fp[-3:] == &#39;.py&#39;:
        raise Exception

    mod_name = _get_module_name_from_path(fp)

    # When the python file is imported and executed all the Cdev resources are created
    mod = module_loader.import_module(mod_name, denote_output=True)

    resource_rv = []
    reference_rv = []

    functions_to_parse: List[str] = []
    function_name_to_info: Dict[str, simple_function_model] = {}


    for i in dir(mod):
        obj = getattr(mod, i)

        if isinstance(obj, Resource):
            # Find all the Resources in the module and render them

            if isinstance(obj, SimpleFunction):
                # Functions are a special case as they will go through the parser and the output
                # of that will be the returned resource
                functions_to_parse.append(obj.configuration.handler)
                function_name_to_info[obj.configuration.handler] = obj
                
            else:
                resource_rv.append(obj.render())

        elif isinstance(obj, Resource_Reference):
            reference_rv.append(obj.render())

    if functions_to_parse:
        log.debug(&#34;Parsing functions (%s) from %s&#34;, functions_to_parse, fp)
        parsed_function_info, parsed_dependency_info = _parse_serverless_functions(
            fp, 
            functions_to_parse,
            handler_name_to_info=function_name_to_info
        )

        resource_rv.extend(parsed_function_info)
        resource_rv.extend(parsed_dependency_info)
        

    return resource_rv, reference_rv



def _parse_serverless_functions(
    filepath: FilePath,
    functions_names_to_parse: List[str],
    handler_name_to_info: Dict[str, SimpleFunction],
    manual_includes: Dict = {},
    global_includes: List = [],
) -&gt; Tuple[List[simple_function_model], List[DependencyLayer]]:
    &#34;&#34;&#34;Parse a given set of function names from a given file

    Args:
        filepath (FilePath): The original file
        functions_names_to_parse (List[str]): functions to parse
        handler_name_to_info (Dict[str, SimpleFunction]): dict of additional information 
        manual_includes (Dict, optional): Dict of information about extra lines to include. Defaults to {}.
        global_includes (List, optional): List of global lines to include. Defaults to [].

    Returns:
        Tuple[List[simple_function_model], List[DependencyLayer]]: Functions and Dependencies parsed

    Use the `serverless_parser` library to get information about each desired function and its dependencies.
    Then use that information to create the needed archives for the functions and return the information as
    Resources.
    &#34;&#34;&#34;

    # Get all the info about a set of functions from the original file
    parsed_file_info = serverless_parser.parse_functions_from_file(
        filepath, include_functions=functions_names_to_parse, remove_top_annotation=True
    )

    # Base path that the all the archives will go 
    base_archive_path = os.path.join(
        Workspace.instance().settings.INTERMEDIATE_FOLDER_LOCATION,
        Workspace.instance().get_resource_state_uuid(),
    )

    if not os.path.isdir(base_archive_path):
        os.mkdir(base_archive_path)

    if Workspace.instance().settings.USE_DOCKER:
        # IF the user has denoted that they want to use Docker to build dependencies for 
        # other architectures, then make sure a downloads cache is set up
        download_cache = os.path.join(
            Workspace.instance().settings.INTERMEDIATE_FOLDER_LOCATION,
            &#34;.download_cache&#34;,
        )

        if not os.path.isdir(download_cache):
            os.mkdir(download_cache)

    else:
        download_cache = None
    
    rv = []
    seen_layers = {}

    for parsed_function in parsed_file_info.parsed_functions:

        previous_info = handler_name_to_info.get(parsed_function.name)

        needed_module_information = package_mananger.get_top_level_module_info(
            parsed_function.imported_packages, filepath, previous_info.platform, download_cache
        )

        log.debug(&#34;Needed modules (%s) for %s&#34;, needed_module_information, parsed_function.name)

        (
            handler_archive_path,
            handler_archive_hash,
            base_handler_path,
            dependencies_info,
        ) = writer.create_full_deployment_package(
            filepath,
            parsed_function.get_line_numbers_serializeable(),
            parsed_function.name,
            base_archive_path,
            pkgs=needed_module_information,
        )
        
        
        # Update the seen packages 
        if dependencies_info:
            # Helps return only one copy of each layer for the file
            seen_layers.update(
              {x.hash:x.render() for x in dependencies_info}
            )

        handler_path = base_handler_path + &#34;.&#34; + parsed_function.name

        new_configuration = SimpleFunctionConfiguration(
            handler=handler_path,
            description=previous_info.configuration.description,
            environment_variables=previous_info.configuration.environment_variables
        )

        new_function = SimpleFunction(
            cdev_name=previous_info.name,
            filepath=paths.get_full_path_from_workspace_base(handler_archive_path),
            events=previous_info.events,
            configuration=new_configuration,
            function_permissions=previous_info.granted_permissions,
            external_dependencies=dependencies_info if dependencies_info else [],
            src_code_hash=handler_archive_hash,
            nonce=previous_info.nonce,
            platform=previous_info.platform
        )

    
        rv.append(new_function.render())

    return rv, [layer for _,layer in seen_layers.items()]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="core.utils.fs_manager.finder.parse_folder"><code class="name flex">
<span>def <span class="ident">parse_folder</span></span>(<span>folder_path: pydantic.types.DirectoryPath) ‑> Tuple[List[<a class="" title="core.constructs.resource.ResourceModel" href="../../constructs/resource.html#core.constructs.resource.ResourceModel">ResourceModel</a>], List[<a class="" title="core.constructs.resource.ResourceReferenceModel" href="../../constructs/resource.html#core.constructs.resource.ResourceReferenceModel">ResourceReferenceModel</a>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Search through the given folder looking for resource and references in Python files. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>folder_path</code></strong> :&ensp;<code>DirectoryPath</code></dt>
<dd>The directory to parse</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Tuple[
List[ResourceModel],
List[ResourceReferenceModel]
]
Specifically, it loads all available python files and uses the loaded module to determine
the resources defined in the files. Any resource or reference defined in the global
context of the file will be detected.</p>
<p>Most resources are passed back as is, but there are optimizations performed on the <code>simple functions</code>.
Namely, Serverless functions are parsed to optimized the actual deployed artifact using the
cparser library and then have their dependencies managed also.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_folder(
    folder_path: DirectoryPath, 
) -&gt; Tuple[List[ResourceModel], List[ResourceReferenceModel]]:
    &#34;&#34;&#34;Search through the given folder looking for resource and references in Python files. 

    Args:
        folder_path (DirectoryPath): The directory to parse

    Returns:
        Tuple[
            List[ResourceModel],
            List[ResourceReferenceModel]
        ]
    
    Specifically, it loads all available python files and uses the loaded module to determine 
    the resources defined in the files. Any resource or reference defined in the global
    context of the file will be detected.
    
    Most resources are passed back as is, but there are optimizations performed on the `simple functions`. 
    Namely, Serverless functions are parsed to optimized the actual deployed artifact using the
    cparser library and then have their dependencies managed also.
    &#34;&#34;&#34;
    if not os.path.isdir(folder_path):
        raise Exception

    log.debug(&#34;Finding resources in folder %s&#34;, folder_path)

    python_files = [
        f
        for f in os.listdir(folder_path)
        if os.path.isfile(os.path.join(folder_path, f)) and f[-3:] == &#34;.py&#34;
    ]

    # [{&lt;resource&gt;}]
    resources_rv = SortedKeyList(key=lambda x: x.name)
    references_rv = SortedKeyList(key=lambda x: x.name)


    for pf in python_files:
        found_resources, found_references = _find_resources_information_from_file(
            os.path.join(folder_path, pf)
        )

        if found_resources:
            resources_rv.update(found_resources)

        if found_references:
            references_rv.update(found_references)

    # Any duplicate layers can be removed 
    cleaned_resources_rv = _deduplicate_layers_from_resource_list(resources_rv)

    return cleaned_resources_rv, references_rv</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<img class='logo-img' src="https://s3.amazonaws.com/cdevframework.io/images/CoreLogo.svg" alt="site">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a class="sidebar" title="core.utils.fs_manager" href="index.html">core.utils.fs_manager</a></code></li>
</ul>
</li>
<li><h3><a class='nav-header' href="#header-functions">Functions</a></h3>
<ul >
<li><code><a class="sidebar" title="core.utils.fs_manager.finder.parse_folder" href="#core.utils.fs_manager.finder.parse_folder">parse_folder</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>