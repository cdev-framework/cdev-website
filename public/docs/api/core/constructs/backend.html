<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>core.constructs.backend API documentation</title>
<meta name="description" content="Definition of the functionality of a Backend within the framework …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em;background:#EEE}#content{padding:20px}#sidebar{padding:30px;overflow:hidden;background:#07085d}#sidebar > *:last-child{margin-bottom:2cm}#sidebar::-webkit-scrollbar{width:8px}#sidebar::-webkit-scrollbar-track{border-radius:10px;background:#f1f1f100}#sidebar::-webkit-scrollbar-thumb{border-radius:10px;background:linear-gradient( 37deg,rgb(247,70,58) 1%,rgb(180,62,121) 80% )}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}a.sidebar{color:white;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#f7463a}a.nav-header{color:white}img.logo-img{display:block;margin-left:auto;margin-right:auto;width:25%}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#e0e0e0;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{height:100vh;overflow:auto;position:sticky;top:0;background:#07085d}#content{width:70%;max-width:200ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<!--<link rel="stylesheet"
href='https://cdevwebsitestaging.s3.amazonaws.com/bootstrap/css/bootstrap.min.css'>-->
<script href='/bootstrap/css/bootstrap.js'></script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>core.constructs.backend</code></h1>
</header>
<section id="section-intro">
<p>Definition of the functionality of a Backend within the framework</p>
<p>A Backend is designed to be the single central place for persistent storage within the framework. It is responsible
for managing all changes within the state of a project. The backend touches almost all other primitives within
the framework. To gain a better understanding of its larger role with the framework, refer to the documentation
about the design of the framework (link).</p>
<p>This file provides the definition of the functionality a backend should implement, but it does not provide
a concrete implementation. </p>
<p>This file also contains the definition of how to configure and dynamically load a backend class. To denote a
concrete implementation, a python <code>module</code> and <code>class</code> must be provide. These should both be strings. They are
used to load a class that inherits from the base <code><a class="" title="core.constructs.backend.Backend" href="#core.constructs.backend.Backend">Backend</a></code> class. It also takes in a generic dictionary to be
passed as configuration into the dynamicall loaded class.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Definition of the functionality of a Backend within the framework

A Backend is designed to be the single central place for persistent storage within the framework. It is responsible
for managing all changes within the state of a project. The backend touches almost all other primitives within
the framework. To gain a better understanding of its larger role with the framework, refer to the documentation
about the design of the framework (link).

This file provides the definition of the functionality a backend should implement, but it does not provide 
a concrete implementation. 

This file also contains the definition of how to configure and dynamically load a backend class. To denote a 
concrete implementation, a python `module` and `class` must be provide. These should both be strings. They are
used to load a class that inherits from the base `Backend` class. It also takes in a generic dictionary to be 
passed as configuration into the dynamicall loaded class.

&#34;&#34;&#34;
import inspect
from typing import Dict, Tuple, Any, List
from pydantic import BaseModel

from .components import Component_Difference, ComponentModel

from .resource import Resource_Reference_Difference, ResourceModel, Resource_Difference
from .resource_state import Resource_State

from ..utils.module_loader import import_module


class Backend_Configuration(BaseModel):
    python_module: str
    python_class: str
    config: Dict

    def __init__(
        __pydantic_self__, python_module: str, python_class: str, config: Dict
    ) -&gt; None:
        &#34;&#34;&#34;
        Represents the data needed to create a new cdev backend:

        Parameters:
            python_module: The name of the python module to load as the backend
            config: configuration option for the backend

        &#34;&#34;&#34;

        super().__init__(
            **{
                &#34;python_module&#34;: python_module,
                &#34;python_class&#34;: python_class,
                &#34;config&#34;: config,
            }
        )


class Backend:
    def __init__(self, **kwargs) -&gt; None:
        raise NotImplementedError

    # Api for working with Resource States
    def create_resource_state(
        self, name: str, parent_resource_state_uuid: str = None
    ) -&gt; str:
        &#34;&#34;&#34;
        Create a new resource state within this stored state.

        Args:
            parent_resource_state_uuid (str): The uuid of the parent resource state.
            name (str): the name of this resource state.

        Returns:
            uuid (str): The uuid of the newly created resource state.

        Raises:
            ResourceStateAlreadyExists

        &#34;&#34;&#34;
        raise NotImplementedError

    def delete_resource_state(self, resource_state_uuid: str):
        &#34;&#34;&#34;
        Delete a resource state within this store state.

        Args:
            resource_state_uuid (str): The uuid of the resource state to delete

        Raises:
            ResourceStateDoesNotExist
            ResourceStateNotEmpty
        &#34;&#34;&#34;
        raise NotImplementedError

    def get_resource_state(self, resource_state_uuid: str) -&gt; Resource_State:
        &#34;&#34;&#34;
        Load a resource state from the stored state.

        Args:
            resource_state_uuid (str): The uuid of the desired resource state

        Raises:
            ResourceStateDoesNotExist
        &#34;&#34;&#34;
        raise NotImplementedError

    def get_top_level_resource_states(self) -&gt; List[Resource_State]:
        &#34;&#34;&#34;
        List all the top level resource states for this stored state

        Returns:
            resource_states (List[Resource_States]): Top level resource states.

        Raises:
            ResourceStateDoesNotExist

        &#34;&#34;&#34;
        raise NotImplementedError


    def get_component(
        self, resource_state_uuid: str, component_name: str
    ) -&gt; ComponentModel:
        &#34;&#34;&#34;
        Get a component from the resource state.

        Args:
            resource_state_uuid (str): The resource state that this component will be in.
            component_name (str): Name of the component

        Returns:
            component (ComponentModel): The data for the requested component

        Raises:
            ResourceStateDoesNotExist
            ComponentDoesNotExist
        &#34;&#34;&#34;
        raise NotImplementedError


    def update_component(
        self, resource_state_uuid: str, component_difference: Component_Difference
    ):
        &#34;&#34;&#34;Make an update to the component. 

        Args:
            resource_state_uuid (str): The resource state that the change is in.
            component_difference (Component_Difference): The difference in the component to be made.

        Raises:
            ResourceStateDoesNotExist
            ComponentDoesNotExist
        &#34;&#34;&#34;
        pass


    def get_component_uuid(self, resource_state_uuid: str, component_name: str) -&gt; str:
        &#34;&#34;&#34;
        Get the unique namespace for this resource state and component. 

        Args:
            resource_state_uuid (str): The resource state that this component will be in.
            component_name (str): Name of the component

        Raises:
            ResourceStateDoesNotExist
            ComponentDoesNotExist

        Returns:
            identifier (str): A unique identifier for this namespace
        &#34;&#34;&#34;

    # Api for changing individual Resources
    # The resource state needs to know when a mapper will be attempting to update a cdev resource. It is in charge of
    # determing if the current resource state is capable of handling a change in the resource.
    def create_resource_change_transaction(
        self, resource_state_uuid: str, component_name: str, diff: Resource_Difference
    ) -&gt; Tuple[str, str]:
        &#34;&#34;&#34;
        Create in the Resource State the desire to change a particular resource. If the resource state can currently handle creating
        this change, it will return a base idempotency token that can be used to construct idempotency tokens for deploying the underlying
        cloud resources. If the resource state can not handle the change, it will throw an error.

        Args:
            resource_state_uuid (str): The resource state for this resource change.
            component_name (str): The component this resource change is occuring in.
            diff (Resource_Difference): The desired change in the resource.

        Returns:
            transaction_token (str): The transaction token to be used by the mapper when deploying the resource. This token can be used to give to a cloud
            provider as a idempotency token.
            namespace_token (str): A suffix that can be added to deployed cloud resources that acts as a namespace for the resource within the cloud. 

        Raises:
            ResourceStateDoesNotExist
            ComponentDoesNotExist
        &#34;&#34;&#34;
        raise NotImplementedError

    def complete_resource_change(
        self,
        resource_state_uuid: str,
        component_name: str,
        diff: Resource_Difference,
        transaction_token: str,
        cloud_output: Dict,
        resolved_cloud_information: Dict={}
    ):
        &#34;&#34;&#34;
        Notify the resource state that all changes to a resource have completed successfully. This will cause the resource to
        update the state of the resource to the new state.

        Args:
            resource_state_uuid (str): The resource state for this resource change.
            component_name (str): The component this resource change is occuring in.
            diff (Resource_Difference): The desired change in the resource
            transaction_token (str): Identifying token representing what transaction is being completed
            cloud_output (Dict): Output information from the cloud provider
            resolved_cloud_information (Dict): Information that was resolved from the cloud output of the component to deploy this change. 


        Raises:
            ResourceChangeTransactionDoesNotExist
            ComponentDoesNotExist

        &#34;&#34;&#34;
        raise NotImplementedError

    def fail_resource_change(
        self,
        resource_state_uuid: str,
        component_name: str,
        diff: Resource_Difference,
        transaction_token: str,
        failed_state: Dict,
    ):
        &#34;&#34;&#34;
        Notify the resource state that an attempted change to a resource has failed. The provided failed state should encapsulate any needed information
        for a future mapper to recover the state of the resource back into a proper state.

        Args:
            resource_state_uuid (str): The resource state for this resource change.
            component_name (str): The component this resource change is occuring in.
            diff (Resource_Difference): The desired change in the resource
            transaction_token (str): Identifying token representing what transaction is being completed
            failed_state (Dict): A dictionary containing information a mapper could use to resolve the failed state

        Raises:
            ResourceStateDoesNotExist
            ResourceChangeTransactionDoesNotExist
        &#34;&#34;&#34;
        raise NotImplementedError

    # Api for getting references from other components
    # Components can have references to resources that are managed in other components and it is the responsibility of the backend to resolve those references
    # The backend should be in charge of handling IAM to determine if resolving the reference is possible
    def resolve_reference_change(
        self,
        resource_state_uuid: str,
        diff: Resource_Reference_Difference,
    ):
        &#34;&#34;&#34;
        Either reference or dereference a resource from a different component.

        Args:
            resource_state_uuid (str): The resource state for this resource change.
            component_name (str): The component this resource change is occuring in.
            diff (Resource_Difference): The desired change in the resource

        Raises:
            ResourceReferenceError
        &#34;&#34;&#34;
        raise NotImplementedError

    # Api for working with a resource states failed resource updates
    # We can either update the failed state by the mapper attempting to fix the underlying issue, or
    # We can recover the resource to either the new state or previous state by the mapper fixing the issues, or
    # We can just delete the failure from our failed state (not recommended unless you know what you are doing because it can leave resources in the cloud)
    def change_failed_state_of_resource_change(
        self, resource_state_uuid: str, transaction_token: str, new_failed_state: Dict
    ):
        &#34;&#34;&#34;
        Update the failed state of a &#39;resource change&#39;.

        Args:
            resource_state_uuid (str): The resource state that this transaction is in.
            transaction_token (str): Identifying token for the failed transaction.
            new_failed_state (Dict): The new failed state of the transaction.

        Raises:
            ResourceStateDoesNotExist
            ResourceChangeTransactionDoesNotExist

        &#34;&#34;&#34;
        raise NotImplementedError

    def recover_failed_resource_change(
        self,
        resource_state_uuid: str,
        transaction_token: str,
        to_previous_state: bool = True,
    ):
        &#34;&#34;&#34;
        Recover the state of the change back to the previous state or forward to the new state. Note this will result in the failed resource change being removed from the stored state.

        Args:
            resource_state_uuid (str): The resource state that this transaction is in.
            transaction_token (str): Identifying token for the failed transaction.
            to_previous_state (bool): Bool to decide if the resource should be transitioned to the previous state or new state.

        Raises:
            ResourceStateDoesNotExist
            ComponentDoesNotExist
            ResourceChangeTransactionDoesNotExist
        &#34;&#34;&#34;
        raise NotImplementedError

    def remove_failed_resource_change(
        self, resource_state_uuid: str, transaction_token: str
    ):
        &#34;&#34;&#34;
        Completely remove the failed resource change from the stored state. Note that this should be used with caution as it can lead to hanging cloud resources.

        Args:
            resource_state_uuid (str): The resource state that this transaction is in.
            transaction_token (str): Identifying token for the failed transaction.

        Raises:
            ResourceStateDoesNotExist
            ResourceChangeTransactionDoesNotExist
        &#34;&#34;&#34;
        raise NotImplementedError

    # Api for getting information about a resource from the backend
    def get_resource_by_name(
        self,
        resource_state_uuid: str,
        component_name: str,
        resource_type: str,
        resource_name: str,
    ) -&gt; ResourceModel:
        &#34;&#34;&#34;
        Get the state of a resource from a component based on the name of the resource

        Args:
            resource_state_uuid (str): The resource state for this resource.
            component_name (str): The component this resource is in.
            resource_type: The RUUID of the resource desired
            resource_name: The name of the resource desired

        Raises:
            ResourceStateDoesNotExist
            ComponentDoesNotExist
            ResourceDoesNotExist
        &#34;&#34;&#34;
        raise NotImplementedError

    def get_resource_by_hash(
        self,
        resource_state_uuid: str,
        component_name: str,
        resource_type: str,
        resource_hash: str,
    ) -&gt; ResourceModel:
        &#34;&#34;&#34;
        Get the state of a resource from a component based on the hash of the resource

        Args:
            resource_state_uuid (str): The resource state for this resource.
            component_name (str): The component this resource is in.
            resource_type (str): The RUUID of the resource desired.
            resource_hash (str): The hash of the resource desired.

        Raises:
            ResourceStateDoesNotExist
            ComponentDoesNotExist
            ResourceDoesNotExist
        &#34;&#34;&#34;
        raise NotImplementedError

    def get_cloud_output_value_by_name(
        self,
        resource_state_uuid: str,
        component_name: str,
        resource_type: str,
        resource_name: str,
        key: str,
    ) -&gt; Any:
        &#34;&#34;&#34;
        Get an output value from the cloud provider for a resource by the name of the resource. This function also takes an optional function as a parameter
        that will be executed on the output and should return a transformed version of the information.

        Args:
            resource_state_uuid (str): The resource state for this resource.
            component_name (str): The component this resource is in.
            resource_type (str): The RUUID of the resource desired
            resource_name (str): The hash of the resource desired
            key (str): The key for the desired value

        Raises:
            ResourceStateDoesNotExist
            ComponentDoesNotExist
            CloudOutputDoesNotExist
            KeyNotInCloudOutput

        &#34;&#34;&#34;
        raise NotImplementedError


    def get_cloud_output_by_name(
        self,
        resource_state_uuid: str,
        component_name: str,
        resource_type: str,
        resource_name: str,
    ) -&gt; Dict:
        &#34;&#34;&#34;
        Get full output from the cloud provider for a resource by the name of the resource.

        Args:
            resource_state_uuid (str): The resource state for this resource.
            component_name (str): The component this resource is in.
            resource_type (str): The RUUID of the resource desired
            resource_name (str): The hash of the resource desired
            key (str): The key for the desired value

        Raises:
            ResourceStateDoesNotExist
            ComponentDoesNotExist
            CloudOutputDoesNotExist
            KeyNotInCloudOutput

        &#34;&#34;&#34;
        raise NotImplementedError

    def get_cloud_output_value_by_hash(
        self,
        resource_state_uuid: str,
        component_uuid: str,
        resource_type: str,
        resource_hash: str,
        key: str,
    ) -&gt; Any:
        &#34;&#34;&#34;
        Get an output value from the cloud provider for a resource by the name of the resource. This function also takes an optional function as a parameter
        that will be executed on the output and should return a transformed version of the information.

        Args:
            resource_state_uuid (str): The resource state for this resource.
            component_name (str): The component this resource is in.
            resource_type (str): The RUUID of the resource desired.
            resource_hash (str): The hash of the resource desired.
            key (str): The key for the desired value.

        Raises:
            ResourceStateDoesNotExist
            ComponentDoesNotExist
            KeyNotInCloudOutput
            CloudOutputDoesNotExist

        &#34;&#34;&#34;
        raise NotImplementedError

    # Api for creating differences between workspace and the backend
    # The backend must be responsible for determining the differences to get to a new potential state because the backend
    # is the one that has to implement the changes.
    # In the future, this will also allow for the backend to manage IAM permissions for creating, updating, referencing, etc
    # the actual cdev resources.
    def create_differences(
        self,
        resource_state_uuid: str,
        new_components: List[ComponentModel],
        old_components: List[str],
    ) -&gt; Tuple[
        Component_Difference,  Resource_Difference, Resource_Reference_Difference,
    ]:
        &#34;&#34;&#34;
        Create the set of differences from a proposed set of components to a provided set of current components identified by their name. This allows the flexibility for working on a particular
        set of components within a resource state.
        &#34;&#34;&#34;
        raise NotImplementedError


def load_backend(config: Backend_Configuration) -&gt; Backend:
    &#34;&#34;&#34;Dynamically load a backend

    Load a backend by initializing the provided module and looking for the class within the loaded module.

    Args:
        config (Backend_Configuration): configuration of what backend to load.

    Raises:
        Exception: [description]

    Returns:
        Backend: [description]
    &#34;&#34;&#34;
    try:
        backend_module = import_module(config.python_module)
    except Exception as e:
        print(&#34;Error loading backend module&#34;)
        print(f&#34;Error &gt; {e}&#34;)

        raise e

    backend_class = None
    for item in dir(backend_module):
        potential_obj = getattr(backend_module, item)
        if (
            inspect.isclass(potential_obj)
            and issubclass(potential_obj, Backend)
            and item == config.python_class
        ):
            backend_class = potential_obj
            break

    if not backend_class:
        print(f&#34;Could not find {config.python_class} in {config.python_module}&#34;)
        raise Exception

    try:
        # initialize the backend obj with the provided configuration values
        initialized_obj = potential_obj(**config.config)
    except Exception as e:
        print(f&#34;Could not initialize {potential_obj} Class from config {config.config}&#34;)
        raise e

    return initialized_obj</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="core.constructs.backend.load_backend"><code class="name flex">
<span>def <span class="ident">load_backend</span></span>(<span>config: <a class="" title="core.constructs.backend.Backend_Configuration" href="#core.constructs.backend.Backend_Configuration">Backend_Configuration</a>) ‑> <a class="" title="core.constructs.backend.Backend" href="#core.constructs.backend.Backend">Backend</a></span>
</code></dt>
<dd>
<div class="desc"><p>Dynamically load a backend</p>
<p>Load a backend by initializing the provided module and looking for the class within the loaded module.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code><a class="" title="core.constructs.backend.Backend_Configuration" href="#core.constructs.backend.Backend_Configuration">Backend_Configuration</a></code></dt>
<dd>configuration of what backend to load.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a class="" title="core.constructs.backend.Backend" href="#core.constructs.backend.Backend">Backend</a></code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_backend(config: Backend_Configuration) -&gt; Backend:
    &#34;&#34;&#34;Dynamically load a backend

    Load a backend by initializing the provided module and looking for the class within the loaded module.

    Args:
        config (Backend_Configuration): configuration of what backend to load.

    Raises:
        Exception: [description]

    Returns:
        Backend: [description]
    &#34;&#34;&#34;
    try:
        backend_module = import_module(config.python_module)
    except Exception as e:
        print(&#34;Error loading backend module&#34;)
        print(f&#34;Error &gt; {e}&#34;)

        raise e

    backend_class = None
    for item in dir(backend_module):
        potential_obj = getattr(backend_module, item)
        if (
            inspect.isclass(potential_obj)
            and issubclass(potential_obj, Backend)
            and item == config.python_class
        ):
            backend_class = potential_obj
            break

    if not backend_class:
        print(f&#34;Could not find {config.python_class} in {config.python_module}&#34;)
        raise Exception

    try:
        # initialize the backend obj with the provided configuration values
        initialized_obj = potential_obj(**config.config)
    except Exception as e:
        print(f&#34;Could not initialize {potential_obj} Class from config {config.config}&#34;)
        raise e

    return initialized_obj</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="core.constructs.backend.Backend"><code class="flex name class">
<span>class <span class="ident">Backend</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Backend:
    def __init__(self, **kwargs) -&gt; None:
        raise NotImplementedError

    # Api for working with Resource States
    def create_resource_state(
        self, name: str, parent_resource_state_uuid: str = None
    ) -&gt; str:
        &#34;&#34;&#34;
        Create a new resource state within this stored state.

        Args:
            parent_resource_state_uuid (str): The uuid of the parent resource state.
            name (str): the name of this resource state.

        Returns:
            uuid (str): The uuid of the newly created resource state.

        Raises:
            ResourceStateAlreadyExists

        &#34;&#34;&#34;
        raise NotImplementedError

    def delete_resource_state(self, resource_state_uuid: str):
        &#34;&#34;&#34;
        Delete a resource state within this store state.

        Args:
            resource_state_uuid (str): The uuid of the resource state to delete

        Raises:
            ResourceStateDoesNotExist
            ResourceStateNotEmpty
        &#34;&#34;&#34;
        raise NotImplementedError

    def get_resource_state(self, resource_state_uuid: str) -&gt; Resource_State:
        &#34;&#34;&#34;
        Load a resource state from the stored state.

        Args:
            resource_state_uuid (str): The uuid of the desired resource state

        Raises:
            ResourceStateDoesNotExist
        &#34;&#34;&#34;
        raise NotImplementedError

    def get_top_level_resource_states(self) -&gt; List[Resource_State]:
        &#34;&#34;&#34;
        List all the top level resource states for this stored state

        Returns:
            resource_states (List[Resource_States]): Top level resource states.

        Raises:
            ResourceStateDoesNotExist

        &#34;&#34;&#34;
        raise NotImplementedError


    def get_component(
        self, resource_state_uuid: str, component_name: str
    ) -&gt; ComponentModel:
        &#34;&#34;&#34;
        Get a component from the resource state.

        Args:
            resource_state_uuid (str): The resource state that this component will be in.
            component_name (str): Name of the component

        Returns:
            component (ComponentModel): The data for the requested component

        Raises:
            ResourceStateDoesNotExist
            ComponentDoesNotExist
        &#34;&#34;&#34;
        raise NotImplementedError


    def update_component(
        self, resource_state_uuid: str, component_difference: Component_Difference
    ):
        &#34;&#34;&#34;Make an update to the component. 

        Args:
            resource_state_uuid (str): The resource state that the change is in.
            component_difference (Component_Difference): The difference in the component to be made.

        Raises:
            ResourceStateDoesNotExist
            ComponentDoesNotExist
        &#34;&#34;&#34;
        pass


    def get_component_uuid(self, resource_state_uuid: str, component_name: str) -&gt; str:
        &#34;&#34;&#34;
        Get the unique namespace for this resource state and component. 

        Args:
            resource_state_uuid (str): The resource state that this component will be in.
            component_name (str): Name of the component

        Raises:
            ResourceStateDoesNotExist
            ComponentDoesNotExist

        Returns:
            identifier (str): A unique identifier for this namespace
        &#34;&#34;&#34;

    # Api for changing individual Resources
    # The resource state needs to know when a mapper will be attempting to update a cdev resource. It is in charge of
    # determing if the current resource state is capable of handling a change in the resource.
    def create_resource_change_transaction(
        self, resource_state_uuid: str, component_name: str, diff: Resource_Difference
    ) -&gt; Tuple[str, str]:
        &#34;&#34;&#34;
        Create in the Resource State the desire to change a particular resource. If the resource state can currently handle creating
        this change, it will return a base idempotency token that can be used to construct idempotency tokens for deploying the underlying
        cloud resources. If the resource state can not handle the change, it will throw an error.

        Args:
            resource_state_uuid (str): The resource state for this resource change.
            component_name (str): The component this resource change is occuring in.
            diff (Resource_Difference): The desired change in the resource.

        Returns:
            transaction_token (str): The transaction token to be used by the mapper when deploying the resource. This token can be used to give to a cloud
            provider as a idempotency token.
            namespace_token (str): A suffix that can be added to deployed cloud resources that acts as a namespace for the resource within the cloud. 

        Raises:
            ResourceStateDoesNotExist
            ComponentDoesNotExist
        &#34;&#34;&#34;
        raise NotImplementedError

    def complete_resource_change(
        self,
        resource_state_uuid: str,
        component_name: str,
        diff: Resource_Difference,
        transaction_token: str,
        cloud_output: Dict,
        resolved_cloud_information: Dict={}
    ):
        &#34;&#34;&#34;
        Notify the resource state that all changes to a resource have completed successfully. This will cause the resource to
        update the state of the resource to the new state.

        Args:
            resource_state_uuid (str): The resource state for this resource change.
            component_name (str): The component this resource change is occuring in.
            diff (Resource_Difference): The desired change in the resource
            transaction_token (str): Identifying token representing what transaction is being completed
            cloud_output (Dict): Output information from the cloud provider
            resolved_cloud_information (Dict): Information that was resolved from the cloud output of the component to deploy this change. 


        Raises:
            ResourceChangeTransactionDoesNotExist
            ComponentDoesNotExist

        &#34;&#34;&#34;
        raise NotImplementedError

    def fail_resource_change(
        self,
        resource_state_uuid: str,
        component_name: str,
        diff: Resource_Difference,
        transaction_token: str,
        failed_state: Dict,
    ):
        &#34;&#34;&#34;
        Notify the resource state that an attempted change to a resource has failed. The provided failed state should encapsulate any needed information
        for a future mapper to recover the state of the resource back into a proper state.

        Args:
            resource_state_uuid (str): The resource state for this resource change.
            component_name (str): The component this resource change is occuring in.
            diff (Resource_Difference): The desired change in the resource
            transaction_token (str): Identifying token representing what transaction is being completed
            failed_state (Dict): A dictionary containing information a mapper could use to resolve the failed state

        Raises:
            ResourceStateDoesNotExist
            ResourceChangeTransactionDoesNotExist
        &#34;&#34;&#34;
        raise NotImplementedError

    # Api for getting references from other components
    # Components can have references to resources that are managed in other components and it is the responsibility of the backend to resolve those references
    # The backend should be in charge of handling IAM to determine if resolving the reference is possible
    def resolve_reference_change(
        self,
        resource_state_uuid: str,
        diff: Resource_Reference_Difference,
    ):
        &#34;&#34;&#34;
        Either reference or dereference a resource from a different component.

        Args:
            resource_state_uuid (str): The resource state for this resource change.
            component_name (str): The component this resource change is occuring in.
            diff (Resource_Difference): The desired change in the resource

        Raises:
            ResourceReferenceError
        &#34;&#34;&#34;
        raise NotImplementedError

    # Api for working with a resource states failed resource updates
    # We can either update the failed state by the mapper attempting to fix the underlying issue, or
    # We can recover the resource to either the new state or previous state by the mapper fixing the issues, or
    # We can just delete the failure from our failed state (not recommended unless you know what you are doing because it can leave resources in the cloud)
    def change_failed_state_of_resource_change(
        self, resource_state_uuid: str, transaction_token: str, new_failed_state: Dict
    ):
        &#34;&#34;&#34;
        Update the failed state of a &#39;resource change&#39;.

        Args:
            resource_state_uuid (str): The resource state that this transaction is in.
            transaction_token (str): Identifying token for the failed transaction.
            new_failed_state (Dict): The new failed state of the transaction.

        Raises:
            ResourceStateDoesNotExist
            ResourceChangeTransactionDoesNotExist

        &#34;&#34;&#34;
        raise NotImplementedError

    def recover_failed_resource_change(
        self,
        resource_state_uuid: str,
        transaction_token: str,
        to_previous_state: bool = True,
    ):
        &#34;&#34;&#34;
        Recover the state of the change back to the previous state or forward to the new state. Note this will result in the failed resource change being removed from the stored state.

        Args:
            resource_state_uuid (str): The resource state that this transaction is in.
            transaction_token (str): Identifying token for the failed transaction.
            to_previous_state (bool): Bool to decide if the resource should be transitioned to the previous state or new state.

        Raises:
            ResourceStateDoesNotExist
            ComponentDoesNotExist
            ResourceChangeTransactionDoesNotExist
        &#34;&#34;&#34;
        raise NotImplementedError

    def remove_failed_resource_change(
        self, resource_state_uuid: str, transaction_token: str
    ):
        &#34;&#34;&#34;
        Completely remove the failed resource change from the stored state. Note that this should be used with caution as it can lead to hanging cloud resources.

        Args:
            resource_state_uuid (str): The resource state that this transaction is in.
            transaction_token (str): Identifying token for the failed transaction.

        Raises:
            ResourceStateDoesNotExist
            ResourceChangeTransactionDoesNotExist
        &#34;&#34;&#34;
        raise NotImplementedError

    # Api for getting information about a resource from the backend
    def get_resource_by_name(
        self,
        resource_state_uuid: str,
        component_name: str,
        resource_type: str,
        resource_name: str,
    ) -&gt; ResourceModel:
        &#34;&#34;&#34;
        Get the state of a resource from a component based on the name of the resource

        Args:
            resource_state_uuid (str): The resource state for this resource.
            component_name (str): The component this resource is in.
            resource_type: The RUUID of the resource desired
            resource_name: The name of the resource desired

        Raises:
            ResourceStateDoesNotExist
            ComponentDoesNotExist
            ResourceDoesNotExist
        &#34;&#34;&#34;
        raise NotImplementedError

    def get_resource_by_hash(
        self,
        resource_state_uuid: str,
        component_name: str,
        resource_type: str,
        resource_hash: str,
    ) -&gt; ResourceModel:
        &#34;&#34;&#34;
        Get the state of a resource from a component based on the hash of the resource

        Args:
            resource_state_uuid (str): The resource state for this resource.
            component_name (str): The component this resource is in.
            resource_type (str): The RUUID of the resource desired.
            resource_hash (str): The hash of the resource desired.

        Raises:
            ResourceStateDoesNotExist
            ComponentDoesNotExist
            ResourceDoesNotExist
        &#34;&#34;&#34;
        raise NotImplementedError

    def get_cloud_output_value_by_name(
        self,
        resource_state_uuid: str,
        component_name: str,
        resource_type: str,
        resource_name: str,
        key: str,
    ) -&gt; Any:
        &#34;&#34;&#34;
        Get an output value from the cloud provider for a resource by the name of the resource. This function also takes an optional function as a parameter
        that will be executed on the output and should return a transformed version of the information.

        Args:
            resource_state_uuid (str): The resource state for this resource.
            component_name (str): The component this resource is in.
            resource_type (str): The RUUID of the resource desired
            resource_name (str): The hash of the resource desired
            key (str): The key for the desired value

        Raises:
            ResourceStateDoesNotExist
            ComponentDoesNotExist
            CloudOutputDoesNotExist
            KeyNotInCloudOutput

        &#34;&#34;&#34;
        raise NotImplementedError


    def get_cloud_output_by_name(
        self,
        resource_state_uuid: str,
        component_name: str,
        resource_type: str,
        resource_name: str,
    ) -&gt; Dict:
        &#34;&#34;&#34;
        Get full output from the cloud provider for a resource by the name of the resource.

        Args:
            resource_state_uuid (str): The resource state for this resource.
            component_name (str): The component this resource is in.
            resource_type (str): The RUUID of the resource desired
            resource_name (str): The hash of the resource desired
            key (str): The key for the desired value

        Raises:
            ResourceStateDoesNotExist
            ComponentDoesNotExist
            CloudOutputDoesNotExist
            KeyNotInCloudOutput

        &#34;&#34;&#34;
        raise NotImplementedError

    def get_cloud_output_value_by_hash(
        self,
        resource_state_uuid: str,
        component_uuid: str,
        resource_type: str,
        resource_hash: str,
        key: str,
    ) -&gt; Any:
        &#34;&#34;&#34;
        Get an output value from the cloud provider for a resource by the name of the resource. This function also takes an optional function as a parameter
        that will be executed on the output and should return a transformed version of the information.

        Args:
            resource_state_uuid (str): The resource state for this resource.
            component_name (str): The component this resource is in.
            resource_type (str): The RUUID of the resource desired.
            resource_hash (str): The hash of the resource desired.
            key (str): The key for the desired value.

        Raises:
            ResourceStateDoesNotExist
            ComponentDoesNotExist
            KeyNotInCloudOutput
            CloudOutputDoesNotExist

        &#34;&#34;&#34;
        raise NotImplementedError

    # Api for creating differences between workspace and the backend
    # The backend must be responsible for determining the differences to get to a new potential state because the backend
    # is the one that has to implement the changes.
    # In the future, this will also allow for the backend to manage IAM permissions for creating, updating, referencing, etc
    # the actual cdev resources.
    def create_differences(
        self,
        resource_state_uuid: str,
        new_components: List[ComponentModel],
        old_components: List[str],
    ) -&gt; Tuple[
        Component_Difference,  Resource_Difference, Resource_Reference_Difference,
    ]:
        &#34;&#34;&#34;
        Create the set of differences from a proposed set of components to a provided set of current components identified by their name. This allows the flexibility for working on a particular
        set of components within a resource state.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a class="" title="core.default.backend.LocalBackend" href="../default/backend.html#core.default.backend.LocalBackend">LocalBackend</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="core.constructs.backend.Backend.change_failed_state_of_resource_change"><code class="name flex">
<span>def <span class="ident">change_failed_state_of_resource_change</span></span>(<span>self, resource_state_uuid: str, transaction_token: str, new_failed_state: Dict[~KT, ~VT])</span>
</code></dt>
<dd>
<div class="desc"><p>Update the failed state of a 'resource change'.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_state_uuid</code></strong> :&ensp;<code>str</code></dt>
<dd>The resource state that this transaction is in.</dd>
<dt><strong><code>transaction_token</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifying token for the failed transaction.</dd>
<dt><strong><code>new_failed_state</code></strong> :&ensp;<code>Dict</code></dt>
<dd>The new failed state of the transaction.</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>ResourceStateDoesNotExist
ResourceChangeTransactionDoesNotExist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_failed_state_of_resource_change(
    self, resource_state_uuid: str, transaction_token: str, new_failed_state: Dict
):
    &#34;&#34;&#34;
    Update the failed state of a &#39;resource change&#39;.

    Args:
        resource_state_uuid (str): The resource state that this transaction is in.
        transaction_token (str): Identifying token for the failed transaction.
        new_failed_state (Dict): The new failed state of the transaction.

    Raises:
        ResourceStateDoesNotExist
        ResourceChangeTransactionDoesNotExist

    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="core.constructs.backend.Backend.complete_resource_change"><code class="name flex">
<span>def <span class="ident">complete_resource_change</span></span>(<span>self, resource_state_uuid: str, component_name: str, diff: <a class="" title="core.constructs.resource.Resource_Difference" href="resource.html#core.constructs.resource.Resource_Difference">Resource_Difference</a>, transaction_token: str, cloud_output: Dict[~KT, ~VT], resolved_cloud_information: Dict[~KT, ~VT] = {})</span>
</code></dt>
<dd>
<div class="desc"><p>Notify the resource state that all changes to a resource have completed successfully. This will cause the resource to
update the state of the resource to the new state.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_state_uuid</code></strong> :&ensp;<code>str</code></dt>
<dd>The resource state for this resource change.</dd>
<dt><strong><code>component_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The component this resource change is occuring in.</dd>
<dt><strong><code>diff</code></strong> :&ensp;<code>Resource_Difference</code></dt>
<dd>The desired change in the resource</dd>
<dt><strong><code>transaction_token</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifying token representing what transaction is being completed</dd>
<dt><strong><code>cloud_output</code></strong> :&ensp;<code>Dict</code></dt>
<dd>Output information from the cloud provider</dd>
<dt><strong><code>resolved_cloud_information</code></strong> :&ensp;<code>Dict</code></dt>
<dd>Information that was resolved from the cloud output of the component to deploy this change. </dd>
</dl>
<h2 id="raises">Raises</h2>
<p>ResourceChangeTransactionDoesNotExist
ComponentDoesNotExist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def complete_resource_change(
    self,
    resource_state_uuid: str,
    component_name: str,
    diff: Resource_Difference,
    transaction_token: str,
    cloud_output: Dict,
    resolved_cloud_information: Dict={}
):
    &#34;&#34;&#34;
    Notify the resource state that all changes to a resource have completed successfully. This will cause the resource to
    update the state of the resource to the new state.

    Args:
        resource_state_uuid (str): The resource state for this resource change.
        component_name (str): The component this resource change is occuring in.
        diff (Resource_Difference): The desired change in the resource
        transaction_token (str): Identifying token representing what transaction is being completed
        cloud_output (Dict): Output information from the cloud provider
        resolved_cloud_information (Dict): Information that was resolved from the cloud output of the component to deploy this change. 


    Raises:
        ResourceChangeTransactionDoesNotExist
        ComponentDoesNotExist

    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="core.constructs.backend.Backend.create_differences"><code class="name flex">
<span>def <span class="ident">create_differences</span></span>(<span>self, resource_state_uuid: str, new_components: List[<a class="" title="core.constructs.components.ComponentModel" href="components.html#core.constructs.components.ComponentModel">ComponentModel</a>], old_components: List[str]) ‑> Tuple[<a class="" title="core.constructs.components.Component_Difference" href="components.html#core.constructs.components.Component_Difference">Component_Difference</a>, <a class="" title="core.constructs.resource.Resource_Difference" href="resource.html#core.constructs.resource.Resource_Difference">Resource_Difference</a>, <a class="" title="core.constructs.resource.Resource_Reference_Difference" href="resource.html#core.constructs.resource.Resource_Reference_Difference">Resource_Reference_Difference</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Create the set of differences from a proposed set of components to a provided set of current components identified by their name. This allows the flexibility for working on a particular
set of components within a resource state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_differences(
    self,
    resource_state_uuid: str,
    new_components: List[ComponentModel],
    old_components: List[str],
) -&gt; Tuple[
    Component_Difference,  Resource_Difference, Resource_Reference_Difference,
]:
    &#34;&#34;&#34;
    Create the set of differences from a proposed set of components to a provided set of current components identified by their name. This allows the flexibility for working on a particular
    set of components within a resource state.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="core.constructs.backend.Backend.create_resource_change_transaction"><code class="name flex">
<span>def <span class="ident">create_resource_change_transaction</span></span>(<span>self, resource_state_uuid: str, component_name: str, diff: <a class="" title="core.constructs.resource.Resource_Difference" href="resource.html#core.constructs.resource.Resource_Difference">Resource_Difference</a>) ‑> Tuple[str, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Create in the Resource State the desire to change a particular resource. If the resource state can currently handle creating
this change, it will return a base idempotency token that can be used to construct idempotency tokens for deploying the underlying
cloud resources. If the resource state can not handle the change, it will throw an error.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_state_uuid</code></strong> :&ensp;<code>str</code></dt>
<dd>The resource state for this resource change.</dd>
<dt><strong><code>component_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The component this resource change is occuring in.</dd>
<dt><strong><code>diff</code></strong> :&ensp;<code>Resource_Difference</code></dt>
<dd>The desired change in the resource.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>transaction_token (str): The transaction token to be used by the mapper when deploying the resource. This token can be used to give to a cloud
provider as a idempotency token.
namespace_token (str): A suffix that can be added to deployed cloud resources that acts as a namespace for the resource within the cloud. </p>
<h2 id="raises">Raises</h2>
<p>ResourceStateDoesNotExist
ComponentDoesNotExist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_resource_change_transaction(
    self, resource_state_uuid: str, component_name: str, diff: Resource_Difference
) -&gt; Tuple[str, str]:
    &#34;&#34;&#34;
    Create in the Resource State the desire to change a particular resource. If the resource state can currently handle creating
    this change, it will return a base idempotency token that can be used to construct idempotency tokens for deploying the underlying
    cloud resources. If the resource state can not handle the change, it will throw an error.

    Args:
        resource_state_uuid (str): The resource state for this resource change.
        component_name (str): The component this resource change is occuring in.
        diff (Resource_Difference): The desired change in the resource.

    Returns:
        transaction_token (str): The transaction token to be used by the mapper when deploying the resource. This token can be used to give to a cloud
        provider as a idempotency token.
        namespace_token (str): A suffix that can be added to deployed cloud resources that acts as a namespace for the resource within the cloud. 

    Raises:
        ResourceStateDoesNotExist
        ComponentDoesNotExist
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="core.constructs.backend.Backend.create_resource_state"><code class="name flex">
<span>def <span class="ident">create_resource_state</span></span>(<span>self, name: str, parent_resource_state_uuid: str = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new resource state within this stored state.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent_resource_state_uuid</code></strong> :&ensp;<code>str</code></dt>
<dd>The uuid of the parent resource state.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of this resource state.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>uuid (str): The uuid of the newly created resource state.</p>
<h2 id="raises">Raises</h2>
<p>ResourceStateAlreadyExists</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_resource_state(
    self, name: str, parent_resource_state_uuid: str = None
) -&gt; str:
    &#34;&#34;&#34;
    Create a new resource state within this stored state.

    Args:
        parent_resource_state_uuid (str): The uuid of the parent resource state.
        name (str): the name of this resource state.

    Returns:
        uuid (str): The uuid of the newly created resource state.

    Raises:
        ResourceStateAlreadyExists

    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="core.constructs.backend.Backend.delete_resource_state"><code class="name flex">
<span>def <span class="ident">delete_resource_state</span></span>(<span>self, resource_state_uuid: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a resource state within this store state.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_state_uuid</code></strong> :&ensp;<code>str</code></dt>
<dd>The uuid of the resource state to delete</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>ResourceStateDoesNotExist
ResourceStateNotEmpty</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_resource_state(self, resource_state_uuid: str):
    &#34;&#34;&#34;
    Delete a resource state within this store state.

    Args:
        resource_state_uuid (str): The uuid of the resource state to delete

    Raises:
        ResourceStateDoesNotExist
        ResourceStateNotEmpty
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="core.constructs.backend.Backend.fail_resource_change"><code class="name flex">
<span>def <span class="ident">fail_resource_change</span></span>(<span>self, resource_state_uuid: str, component_name: str, diff: <a class="" title="core.constructs.resource.Resource_Difference" href="resource.html#core.constructs.resource.Resource_Difference">Resource_Difference</a>, transaction_token: str, failed_state: Dict[~KT, ~VT])</span>
</code></dt>
<dd>
<div class="desc"><p>Notify the resource state that an attempted change to a resource has failed. The provided failed state should encapsulate any needed information
for a future mapper to recover the state of the resource back into a proper state.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_state_uuid</code></strong> :&ensp;<code>str</code></dt>
<dd>The resource state for this resource change.</dd>
<dt><strong><code>component_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The component this resource change is occuring in.</dd>
<dt><strong><code>diff</code></strong> :&ensp;<code>Resource_Difference</code></dt>
<dd>The desired change in the resource</dd>
<dt><strong><code>transaction_token</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifying token representing what transaction is being completed</dd>
<dt><strong><code>failed_state</code></strong> :&ensp;<code>Dict</code></dt>
<dd>A dictionary containing information a mapper could use to resolve the failed state</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>ResourceStateDoesNotExist
ResourceChangeTransactionDoesNotExist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fail_resource_change(
    self,
    resource_state_uuid: str,
    component_name: str,
    diff: Resource_Difference,
    transaction_token: str,
    failed_state: Dict,
):
    &#34;&#34;&#34;
    Notify the resource state that an attempted change to a resource has failed. The provided failed state should encapsulate any needed information
    for a future mapper to recover the state of the resource back into a proper state.

    Args:
        resource_state_uuid (str): The resource state for this resource change.
        component_name (str): The component this resource change is occuring in.
        diff (Resource_Difference): The desired change in the resource
        transaction_token (str): Identifying token representing what transaction is being completed
        failed_state (Dict): A dictionary containing information a mapper could use to resolve the failed state

    Raises:
        ResourceStateDoesNotExist
        ResourceChangeTransactionDoesNotExist
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="core.constructs.backend.Backend.get_cloud_output_by_name"><code class="name flex">
<span>def <span class="ident">get_cloud_output_by_name</span></span>(<span>self, resource_state_uuid: str, component_name: str, resource_type: str, resource_name: str) ‑> Dict[~KT, ~VT]</span>
</code></dt>
<dd>
<div class="desc"><p>Get full output from the cloud provider for a resource by the name of the resource.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_state_uuid</code></strong> :&ensp;<code>str</code></dt>
<dd>The resource state for this resource.</dd>
<dt><strong><code>component_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The component this resource is in.</dd>
<dt><strong><code>resource_type</code></strong> :&ensp;<code>str</code></dt>
<dd>The RUUID of the resource desired</dd>
<dt><strong><code>resource_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The hash of the resource desired</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>The key for the desired value</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>ResourceStateDoesNotExist
ComponentDoesNotExist
CloudOutputDoesNotExist
KeyNotInCloudOutput</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cloud_output_by_name(
    self,
    resource_state_uuid: str,
    component_name: str,
    resource_type: str,
    resource_name: str,
) -&gt; Dict:
    &#34;&#34;&#34;
    Get full output from the cloud provider for a resource by the name of the resource.

    Args:
        resource_state_uuid (str): The resource state for this resource.
        component_name (str): The component this resource is in.
        resource_type (str): The RUUID of the resource desired
        resource_name (str): The hash of the resource desired
        key (str): The key for the desired value

    Raises:
        ResourceStateDoesNotExist
        ComponentDoesNotExist
        CloudOutputDoesNotExist
        KeyNotInCloudOutput

    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="core.constructs.backend.Backend.get_cloud_output_value_by_hash"><code class="name flex">
<span>def <span class="ident">get_cloud_output_value_by_hash</span></span>(<span>self, resource_state_uuid: str, component_uuid: str, resource_type: str, resource_hash: str, key: str) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Get an output value from the cloud provider for a resource by the name of the resource. This function also takes an optional function as a parameter
that will be executed on the output and should return a transformed version of the information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_state_uuid</code></strong> :&ensp;<code>str</code></dt>
<dd>The resource state for this resource.</dd>
<dt><strong><code>component_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The component this resource is in.</dd>
<dt><strong><code>resource_type</code></strong> :&ensp;<code>str</code></dt>
<dd>The RUUID of the resource desired.</dd>
<dt><strong><code>resource_hash</code></strong> :&ensp;<code>str</code></dt>
<dd>The hash of the resource desired.</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>The key for the desired value.</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>ResourceStateDoesNotExist
ComponentDoesNotExist
KeyNotInCloudOutput
CloudOutputDoesNotExist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cloud_output_value_by_hash(
    self,
    resource_state_uuid: str,
    component_uuid: str,
    resource_type: str,
    resource_hash: str,
    key: str,
) -&gt; Any:
    &#34;&#34;&#34;
    Get an output value from the cloud provider for a resource by the name of the resource. This function also takes an optional function as a parameter
    that will be executed on the output and should return a transformed version of the information.

    Args:
        resource_state_uuid (str): The resource state for this resource.
        component_name (str): The component this resource is in.
        resource_type (str): The RUUID of the resource desired.
        resource_hash (str): The hash of the resource desired.
        key (str): The key for the desired value.

    Raises:
        ResourceStateDoesNotExist
        ComponentDoesNotExist
        KeyNotInCloudOutput
        CloudOutputDoesNotExist

    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="core.constructs.backend.Backend.get_cloud_output_value_by_name"><code class="name flex">
<span>def <span class="ident">get_cloud_output_value_by_name</span></span>(<span>self, resource_state_uuid: str, component_name: str, resource_type: str, resource_name: str, key: str) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Get an output value from the cloud provider for a resource by the name of the resource. This function also takes an optional function as a parameter
that will be executed on the output and should return a transformed version of the information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_state_uuid</code></strong> :&ensp;<code>str</code></dt>
<dd>The resource state for this resource.</dd>
<dt><strong><code>component_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The component this resource is in.</dd>
<dt><strong><code>resource_type</code></strong> :&ensp;<code>str</code></dt>
<dd>The RUUID of the resource desired</dd>
<dt><strong><code>resource_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The hash of the resource desired</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>The key for the desired value</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>ResourceStateDoesNotExist
ComponentDoesNotExist
CloudOutputDoesNotExist
KeyNotInCloudOutput</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cloud_output_value_by_name(
    self,
    resource_state_uuid: str,
    component_name: str,
    resource_type: str,
    resource_name: str,
    key: str,
) -&gt; Any:
    &#34;&#34;&#34;
    Get an output value from the cloud provider for a resource by the name of the resource. This function also takes an optional function as a parameter
    that will be executed on the output and should return a transformed version of the information.

    Args:
        resource_state_uuid (str): The resource state for this resource.
        component_name (str): The component this resource is in.
        resource_type (str): The RUUID of the resource desired
        resource_name (str): The hash of the resource desired
        key (str): The key for the desired value

    Raises:
        ResourceStateDoesNotExist
        ComponentDoesNotExist
        CloudOutputDoesNotExist
        KeyNotInCloudOutput

    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="core.constructs.backend.Backend.get_component"><code class="name flex">
<span>def <span class="ident">get_component</span></span>(<span>self, resource_state_uuid: str, component_name: str) ‑> <a class="" title="core.constructs.components.ComponentModel" href="components.html#core.constructs.components.ComponentModel">ComponentModel</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get a component from the resource state.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_state_uuid</code></strong> :&ensp;<code>str</code></dt>
<dd>The resource state that this component will be in.</dd>
<dt><strong><code>component_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the component</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>component (ComponentModel): The data for the requested component</p>
<h2 id="raises">Raises</h2>
<p>ResourceStateDoesNotExist
ComponentDoesNotExist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_component(
    self, resource_state_uuid: str, component_name: str
) -&gt; ComponentModel:
    &#34;&#34;&#34;
    Get a component from the resource state.

    Args:
        resource_state_uuid (str): The resource state that this component will be in.
        component_name (str): Name of the component

    Returns:
        component (ComponentModel): The data for the requested component

    Raises:
        ResourceStateDoesNotExist
        ComponentDoesNotExist
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="core.constructs.backend.Backend.get_component_uuid"><code class="name flex">
<span>def <span class="ident">get_component_uuid</span></span>(<span>self, resource_state_uuid: str, component_name: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get the unique namespace for this resource state and component. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_state_uuid</code></strong> :&ensp;<code>str</code></dt>
<dd>The resource state that this component will be in.</dd>
<dt><strong><code>component_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the component</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>ResourceStateDoesNotExist
ComponentDoesNotExist</p>
<h2 id="returns">Returns</h2>
<p>identifier (str): A unique identifier for this namespace</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_component_uuid(self, resource_state_uuid: str, component_name: str) -&gt; str:
    &#34;&#34;&#34;
    Get the unique namespace for this resource state and component. 

    Args:
        resource_state_uuid (str): The resource state that this component will be in.
        component_name (str): Name of the component

    Raises:
        ResourceStateDoesNotExist
        ComponentDoesNotExist

    Returns:
        identifier (str): A unique identifier for this namespace
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="core.constructs.backend.Backend.get_resource_by_hash"><code class="name flex">
<span>def <span class="ident">get_resource_by_hash</span></span>(<span>self, resource_state_uuid: str, component_name: str, resource_type: str, resource_hash: str) ‑> <a class="" title="core.constructs.resource.ResourceModel" href="resource.html#core.constructs.resource.ResourceModel">ResourceModel</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get the state of a resource from a component based on the hash of the resource</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_state_uuid</code></strong> :&ensp;<code>str</code></dt>
<dd>The resource state for this resource.</dd>
<dt><strong><code>component_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The component this resource is in.</dd>
<dt><strong><code>resource_type</code></strong> :&ensp;<code>str</code></dt>
<dd>The RUUID of the resource desired.</dd>
<dt><strong><code>resource_hash</code></strong> :&ensp;<code>str</code></dt>
<dd>The hash of the resource desired.</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>ResourceStateDoesNotExist
ComponentDoesNotExist
ResourceDoesNotExist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_resource_by_hash(
    self,
    resource_state_uuid: str,
    component_name: str,
    resource_type: str,
    resource_hash: str,
) -&gt; ResourceModel:
    &#34;&#34;&#34;
    Get the state of a resource from a component based on the hash of the resource

    Args:
        resource_state_uuid (str): The resource state for this resource.
        component_name (str): The component this resource is in.
        resource_type (str): The RUUID of the resource desired.
        resource_hash (str): The hash of the resource desired.

    Raises:
        ResourceStateDoesNotExist
        ComponentDoesNotExist
        ResourceDoesNotExist
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="core.constructs.backend.Backend.get_resource_by_name"><code class="name flex">
<span>def <span class="ident">get_resource_by_name</span></span>(<span>self, resource_state_uuid: str, component_name: str, resource_type: str, resource_name: str) ‑> <a class="" title="core.constructs.resource.ResourceModel" href="resource.html#core.constructs.resource.ResourceModel">ResourceModel</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get the state of a resource from a component based on the name of the resource</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_state_uuid</code></strong> :&ensp;<code>str</code></dt>
<dd>The resource state for this resource.</dd>
<dt><strong><code>component_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The component this resource is in.</dd>
<dt><strong><code>resource_type</code></strong></dt>
<dd>The RUUID of the resource desired</dd>
<dt><strong><code>resource_name</code></strong></dt>
<dd>The name of the resource desired</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>ResourceStateDoesNotExist
ComponentDoesNotExist
ResourceDoesNotExist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_resource_by_name(
    self,
    resource_state_uuid: str,
    component_name: str,
    resource_type: str,
    resource_name: str,
) -&gt; ResourceModel:
    &#34;&#34;&#34;
    Get the state of a resource from a component based on the name of the resource

    Args:
        resource_state_uuid (str): The resource state for this resource.
        component_name (str): The component this resource is in.
        resource_type: The RUUID of the resource desired
        resource_name: The name of the resource desired

    Raises:
        ResourceStateDoesNotExist
        ComponentDoesNotExist
        ResourceDoesNotExist
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="core.constructs.backend.Backend.get_resource_state"><code class="name flex">
<span>def <span class="ident">get_resource_state</span></span>(<span>self, resource_state_uuid: str) ‑> <a class="" title="core.constructs.resource_state.Resource_State" href="resource_state.html#core.constructs.resource_state.Resource_State">Resource_State</a></span>
</code></dt>
<dd>
<div class="desc"><p>Load a resource state from the stored state.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_state_uuid</code></strong> :&ensp;<code>str</code></dt>
<dd>The uuid of the desired resource state</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>ResourceStateDoesNotExist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_resource_state(self, resource_state_uuid: str) -&gt; Resource_State:
    &#34;&#34;&#34;
    Load a resource state from the stored state.

    Args:
        resource_state_uuid (str): The uuid of the desired resource state

    Raises:
        ResourceStateDoesNotExist
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="core.constructs.backend.Backend.get_top_level_resource_states"><code class="name flex">
<span>def <span class="ident">get_top_level_resource_states</span></span>(<span>self) ‑> List[<a class="" title="core.constructs.resource_state.Resource_State" href="resource_state.html#core.constructs.resource_state.Resource_State">Resource_State</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>List all the top level resource states for this stored state</p>
<h2 id="returns">Returns</h2>
<p>resource_states (List[Resource_States]): Top level resource states.</p>
<h2 id="raises">Raises</h2>
<p>ResourceStateDoesNotExist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_top_level_resource_states(self) -&gt; List[Resource_State]:
    &#34;&#34;&#34;
    List all the top level resource states for this stored state

    Returns:
        resource_states (List[Resource_States]): Top level resource states.

    Raises:
        ResourceStateDoesNotExist

    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="core.constructs.backend.Backend.recover_failed_resource_change"><code class="name flex">
<span>def <span class="ident">recover_failed_resource_change</span></span>(<span>self, resource_state_uuid: str, transaction_token: str, to_previous_state: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Recover the state of the change back to the previous state or forward to the new state. Note this will result in the failed resource change being removed from the stored state.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_state_uuid</code></strong> :&ensp;<code>str</code></dt>
<dd>The resource state that this transaction is in.</dd>
<dt><strong><code>transaction_token</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifying token for the failed transaction.</dd>
<dt><strong><code>to_previous_state</code></strong> :&ensp;<code>bool</code></dt>
<dd>Bool to decide if the resource should be transitioned to the previous state or new state.</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>ResourceStateDoesNotExist
ComponentDoesNotExist
ResourceChangeTransactionDoesNotExist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recover_failed_resource_change(
    self,
    resource_state_uuid: str,
    transaction_token: str,
    to_previous_state: bool = True,
):
    &#34;&#34;&#34;
    Recover the state of the change back to the previous state or forward to the new state. Note this will result in the failed resource change being removed from the stored state.

    Args:
        resource_state_uuid (str): The resource state that this transaction is in.
        transaction_token (str): Identifying token for the failed transaction.
        to_previous_state (bool): Bool to decide if the resource should be transitioned to the previous state or new state.

    Raises:
        ResourceStateDoesNotExist
        ComponentDoesNotExist
        ResourceChangeTransactionDoesNotExist
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="core.constructs.backend.Backend.remove_failed_resource_change"><code class="name flex">
<span>def <span class="ident">remove_failed_resource_change</span></span>(<span>self, resource_state_uuid: str, transaction_token: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Completely remove the failed resource change from the stored state. Note that this should be used with caution as it can lead to hanging cloud resources.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_state_uuid</code></strong> :&ensp;<code>str</code></dt>
<dd>The resource state that this transaction is in.</dd>
<dt><strong><code>transaction_token</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifying token for the failed transaction.</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>ResourceStateDoesNotExist
ResourceChangeTransactionDoesNotExist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_failed_resource_change(
    self, resource_state_uuid: str, transaction_token: str
):
    &#34;&#34;&#34;
    Completely remove the failed resource change from the stored state. Note that this should be used with caution as it can lead to hanging cloud resources.

    Args:
        resource_state_uuid (str): The resource state that this transaction is in.
        transaction_token (str): Identifying token for the failed transaction.

    Raises:
        ResourceStateDoesNotExist
        ResourceChangeTransactionDoesNotExist
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="core.constructs.backend.Backend.resolve_reference_change"><code class="name flex">
<span>def <span class="ident">resolve_reference_change</span></span>(<span>self, resource_state_uuid: str, diff: <a class="" title="core.constructs.resource.Resource_Reference_Difference" href="resource.html#core.constructs.resource.Resource_Reference_Difference">Resource_Reference_Difference</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Either reference or dereference a resource from a different component.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_state_uuid</code></strong> :&ensp;<code>str</code></dt>
<dd>The resource state for this resource change.</dd>
<dt><strong><code>component_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The component this resource change is occuring in.</dd>
<dt><strong><code>diff</code></strong> :&ensp;<code>Resource_Difference</code></dt>
<dd>The desired change in the resource</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>ResourceReferenceError</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve_reference_change(
    self,
    resource_state_uuid: str,
    diff: Resource_Reference_Difference,
):
    &#34;&#34;&#34;
    Either reference or dereference a resource from a different component.

    Args:
        resource_state_uuid (str): The resource state for this resource change.
        component_name (str): The component this resource change is occuring in.
        diff (Resource_Difference): The desired change in the resource

    Raises:
        ResourceReferenceError
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="core.constructs.backend.Backend.update_component"><code class="name flex">
<span>def <span class="ident">update_component</span></span>(<span>self, resource_state_uuid: str, component_difference: <a class="" title="core.constructs.components.Component_Difference" href="components.html#core.constructs.components.Component_Difference">Component_Difference</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Make an update to the component. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_state_uuid</code></strong> :&ensp;<code>str</code></dt>
<dd>The resource state that the change is in.</dd>
<dt><strong><code>component_difference</code></strong> :&ensp;<code>Component_Difference</code></dt>
<dd>The difference in the component to be made.</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>ResourceStateDoesNotExist
ComponentDoesNotExist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_component(
    self, resource_state_uuid: str, component_difference: Component_Difference
):
    &#34;&#34;&#34;Make an update to the component. 

    Args:
        resource_state_uuid (str): The resource state that the change is in.
        component_difference (Component_Difference): The difference in the component to be made.

    Raises:
        ResourceStateDoesNotExist
        ComponentDoesNotExist
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="core.constructs.backend.Backend_Configuration"><code class="flex name class">
<span>class <span class="ident">Backend_Configuration</span></span>
<span>(</span><span>python_module: str, python_class: str, config: Dict[~KT, ~VT])</span>
</code></dt>
<dd>
<div class="desc"><p>Represents the data needed to create a new cdev backend:</p>
<h2 id="parameters">Parameters</h2>
<p>python_module: The name of the python module to load as the backend
config: configuration option for the backend</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Backend_Configuration(BaseModel):
    python_module: str
    python_class: str
    config: Dict

    def __init__(
        __pydantic_self__, python_module: str, python_class: str, config: Dict
    ) -&gt; None:
        &#34;&#34;&#34;
        Represents the data needed to create a new cdev backend:

        Parameters:
            python_module: The name of the python module to load as the backend
            config: configuration option for the backend

        &#34;&#34;&#34;

        super().__init__(
            **{
                &#34;python_module&#34;: python_module,
                &#34;python_class&#34;: python_class,
                &#34;config&#34;: config,
            }
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a class="" title="core.default.backend.Local_Backend_Configuration" href="../default/backend.html#core.default.backend.Local_Backend_Configuration">Local_Backend_Configuration</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="core.constructs.backend.Backend_Configuration.config"><code class="name">var <span class="ident">config</span> : Dict[~KT, ~VT]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="core.constructs.backend.Backend_Configuration.python_class"><code class="name">var <span class="ident">python_class</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="core.constructs.backend.Backend_Configuration.python_module"><code class="name">var <span class="ident">python_module</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<img class='logo-img' src="https://s3.amazonaws.com/cdevframework.io/images/CoreLogo.svg" alt="site">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a class="sidebar" title="core.constructs" href="index.html">core.constructs</a></code></li>
</ul>
</li>
<li><h3><a class='nav-header' href="#header-functions">Functions</a></h3>
<ul >
<li><code><a class="sidebar" title="core.constructs.backend.load_backend" href="#core.constructs.backend.load_backend">load_backend</a></code></li>
</ul>
</li>
<li><h3><a class='nav-header' href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a class="sidebar" title="core.constructs.backend.Backend" href="#core.constructs.backend.Backend">Backend</a></code></h4>
<ul >
<li><code><a class="sidebar" title="core.constructs.backend.Backend.change_failed_state_of_resource_change" href="#core.constructs.backend.Backend.change_failed_state_of_resource_change">change_failed_state_of_resource_change</a></code></li>
<li><code><a class="sidebar" title="core.constructs.backend.Backend.complete_resource_change" href="#core.constructs.backend.Backend.complete_resource_change">complete_resource_change</a></code></li>
<li><code><a class="sidebar" title="core.constructs.backend.Backend.create_differences" href="#core.constructs.backend.Backend.create_differences">create_differences</a></code></li>
<li><code><a class="sidebar" title="core.constructs.backend.Backend.create_resource_change_transaction" href="#core.constructs.backend.Backend.create_resource_change_transaction">create_resource_change_transaction</a></code></li>
<li><code><a class="sidebar" title="core.constructs.backend.Backend.create_resource_state" href="#core.constructs.backend.Backend.create_resource_state">create_resource_state</a></code></li>
<li><code><a class="sidebar" title="core.constructs.backend.Backend.delete_resource_state" href="#core.constructs.backend.Backend.delete_resource_state">delete_resource_state</a></code></li>
<li><code><a class="sidebar" title="core.constructs.backend.Backend.fail_resource_change" href="#core.constructs.backend.Backend.fail_resource_change">fail_resource_change</a></code></li>
<li><code><a class="sidebar" title="core.constructs.backend.Backend.get_cloud_output_by_name" href="#core.constructs.backend.Backend.get_cloud_output_by_name">get_cloud_output_by_name</a></code></li>
<li><code><a class="sidebar" title="core.constructs.backend.Backend.get_cloud_output_value_by_hash" href="#core.constructs.backend.Backend.get_cloud_output_value_by_hash">get_cloud_output_value_by_hash</a></code></li>
<li><code><a class="sidebar" title="core.constructs.backend.Backend.get_cloud_output_value_by_name" href="#core.constructs.backend.Backend.get_cloud_output_value_by_name">get_cloud_output_value_by_name</a></code></li>
<li><code><a class="sidebar" title="core.constructs.backend.Backend.get_component" href="#core.constructs.backend.Backend.get_component">get_component</a></code></li>
<li><code><a class="sidebar" title="core.constructs.backend.Backend.get_component_uuid" href="#core.constructs.backend.Backend.get_component_uuid">get_component_uuid</a></code></li>
<li><code><a class="sidebar" title="core.constructs.backend.Backend.get_resource_by_hash" href="#core.constructs.backend.Backend.get_resource_by_hash">get_resource_by_hash</a></code></li>
<li><code><a class="sidebar" title="core.constructs.backend.Backend.get_resource_by_name" href="#core.constructs.backend.Backend.get_resource_by_name">get_resource_by_name</a></code></li>
<li><code><a class="sidebar" title="core.constructs.backend.Backend.get_resource_state" href="#core.constructs.backend.Backend.get_resource_state">get_resource_state</a></code></li>
<li><code><a class="sidebar" title="core.constructs.backend.Backend.get_top_level_resource_states" href="#core.constructs.backend.Backend.get_top_level_resource_states">get_top_level_resource_states</a></code></li>
<li><code><a class="sidebar" title="core.constructs.backend.Backend.recover_failed_resource_change" href="#core.constructs.backend.Backend.recover_failed_resource_change">recover_failed_resource_change</a></code></li>
<li><code><a class="sidebar" title="core.constructs.backend.Backend.remove_failed_resource_change" href="#core.constructs.backend.Backend.remove_failed_resource_change">remove_failed_resource_change</a></code></li>
<li><code><a class="sidebar" title="core.constructs.backend.Backend.resolve_reference_change" href="#core.constructs.backend.Backend.resolve_reference_change">resolve_reference_change</a></code></li>
<li><code><a class="sidebar" title="core.constructs.backend.Backend.update_component" href="#core.constructs.backend.Backend.update_component">update_component</a></code></li>
</ul>
</li>
<li>
<h4><code><a class="sidebar" title="core.constructs.backend.Backend_Configuration" href="#core.constructs.backend.Backend_Configuration">Backend_Configuration</a></code></h4>
<ul >
<li><code><a class="sidebar" title="core.constructs.backend.Backend_Configuration.config" href="#core.constructs.backend.Backend_Configuration.config">config</a></code></li>
<li><code><a class="sidebar" title="core.constructs.backend.Backend_Configuration.python_class" href="#core.constructs.backend.Backend_Configuration.python_class">python_class</a></code></li>
<li><code><a class="sidebar" title="core.constructs.backend.Backend_Configuration.python_module" href="#core.constructs.backend.Backend_Configuration.python_module">python_module</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>